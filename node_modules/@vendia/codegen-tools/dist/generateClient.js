var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import fs from 'fs';
import { buildSchema } from 'graphql';
import path from 'path';
import { compileTs } from './compileTypescript';
import { generateTypescript } from './generateTypescript';
export const generateClient = ({ dotVendiaDirPath, debugInfo = {}, debug = function () {
    /* No-op */
}, vendiaMonorepoOverrides, version, }) => __awaiter(void 0, void 0, void 0, function* () {
    // TODO - allow user to change path to schema.json in vendia.yml
    debug('dotVendiaDirPath from generateClient.ts', dotVendiaDirPath);
    debugInfo.dotVendiaDirPath = dotVendiaDirPath;
    const dotVendiaExists = fs.existsSync(dotVendiaDirPath);
    let graphQlSchema;
    let schemaJson;
    let schemaNamespace;
    if (!dotVendiaExists) {
        console.log(`Could not find .vendia directory — make sure you've run the client:pull command and you're running generate from the root of your project (the same directory as your package.json).`);
        console.log(`Falling back to a generic schema — the generated client will not contain "entities".`);
        schemaNamespace = 'Self';
        schemaJson = {
            $schema: 'http://json-schema.org/draft-07/schema#',
            title: 'Uni Schema',
            description: 'Empty Uni Schema',
            type: 'object',
            properties: {},
        };
        const graphQlString = fs.readFileSync(path.join(__dirname, 'generic-schema.graphql'), 'utf8');
        graphQlSchema = buildSchema(graphQlString);
    }
    else {
        debug('generateClient: dotVendiaDirPath found at', dotVendiaDirPath);
        let schemaJsonString;
        try {
            schemaJsonString = fs.readFileSync(path.join(dotVendiaDirPath, 'schema.json'), 'utf8');
        }
        catch (e) {
            throw new Error(`Could not find schema.json at ${path.join(dotVendiaDirPath, 'schema.json')}.`);
        }
        try {
            schemaJson = JSON.parse(schemaJsonString);
        }
        catch (e) {
            throw new Error(`Could not parse schema.json at ${path.join(dotVendiaDirPath, 'schema.json')}.`);
        }
        if (!(schemaJson === null || schemaJson === void 0 ? void 0 : schemaJson.properties)) {
            throw new Error('schemaJson must be an object with a "properties" field.');
        }
        let configString;
        try {
            configString = fs.readFileSync(path.join(dotVendiaDirPath, 'config.json'), 'utf8');
        }
        catch (e) {
            throw new Error(`Could not find config.json at ${path.join(dotVendiaDirPath, 'config.json')}.`);
        }
        let config;
        try {
            config = JSON.parse(configString);
            schemaNamespace = config.schemaNamespace;
        }
        catch (e) {
            throw new Error(`Could not parse config.json at ${path.join(dotVendiaDirPath, 'config.json')}.`);
        }
        if (typeof schemaNamespace !== 'string') {
            throw new TypeError('schemaNamespace must be a string.');
        }
        let graphQLString;
        try {
            graphQLString = fs.readFileSync(path.join(dotVendiaDirPath, 'schema.graphql'), 'utf8');
        }
        catch (e) {
            throw new Error(`Could not find schema.graphql at ${path.join(dotVendiaDirPath, 'schema.graphql')}.`);
        }
        graphQlSchema = buildSchema(graphQLString);
    }
    let dotVendiaClientPath;
    let installedClientPath;
    if (vendiaMonorepoOverrides) {
        dotVendiaClientPath = vendiaMonorepoOverrides.dotVendiaClientPath;
        if (!fs.existsSync(dotVendiaClientPath)) {
            fs.mkdirSync(dotVendiaClientPath);
        }
        installedClientPath = vendiaMonorepoOverrides.installedClientPath;
    }
    else {
        // Create .vendia-client directory inside node_modules if it doesn't exist
        const nodeModulesPath = path.join(dotVendiaDirPath, '..', 'node_modules');
        if (!fs.existsSync(nodeModulesPath)) {
            throw new Error(`Could not find node_modules dir at ${nodeModulesPath} - make sure you've installed the @vendia/client package before running the generate command.`);
        }
        dotVendiaClientPath = path.join(nodeModulesPath, '.vendia-client');
        if (!fs.existsSync(dotVendiaClientPath)) {
            fs.mkdirSync(dotVendiaClientPath);
        }
        installedClientPath = path.join(dotVendiaDirPath, '..', 'node_modules', '@vendia', 'client');
        if (!fs.existsSync(installedClientPath)) {
            throw new Error(`Could not find @vendia/client at ${installedClientPath}`);
        }
    }
    // Generate SDK and write to .vendia-client
    const sdkString = yield generateTypescript({
        graphQlSchema,
        schemaJson,
        schemaNamespace,
    });
    const sdkPath = path.join(dotVendiaClientPath, 'generated.ts');
    fs.writeFile(sdkPath, sdkString, () => {
        debug('Codegen files generated at:', sdkPath);
        debugInfo.codegenFilesGeneratedAt = sdkPath;
    });
    // Copy src files to .vendia-client
    const installedClientSourcePath = path.join(installedClientPath, 'src');
    copyFolderSync(installedClientSourcePath, dotVendiaClientPath);
    // Remove type def file from previous installation/codegen - we need to test for creation of new version below
    const typeDefFilePath = path.join(dotVendiaClientPath, 'index.d.ts');
    if (fs.existsSync(typeDefFilePath)) {
        debug('Deleted previous index.d.ts file');
        fs.unlinkSync(typeDefFilePath);
    }
    else {
        debug('No previous index.d.ts file to delete');
    }
    // Entry file
    // Also, convert Windows path separators to Max/Linux due to bug in globby used in TSUP
    // https://github.com/egoist/tsup/blob/8230221e4ee689cf070e8e288f098f8484404d53/src/index.ts#L83
    // https://github.com/sindresorhus/globby/issues/179
    const indexFilePath = path.join(dotVendiaClientPath, 'index.ts').replace(/\\/g, '/');
    // Compile typescript to js/dts files - pass reference to tsconfig in @vendia/client
    //  as it won't find it automatically, and it's needed for d.ts generation
    console.log('Compiling TypeScript to js/d.ts files...');
    const tsconfigPath = path.join(installedClientPath, 'tsconfig.json');
    yield compileTs(indexFilePath, version, {
        outDir: dotVendiaClientPath,
        tsconfig: tsconfigPath,
        dts: {
            // The index file is re-exporting types from generated and types so we want to create dts files for those as well.
            entry: [
                indexFilePath,
                path.join(dotVendiaClientPath, 'generated.ts').replace(/\\/g, '/'),
                path.join(dotVendiaClientPath, 'types.ts').replace(/\\/g, '/'),
            ],
        },
    });
    // Module build
    const tsconfigModulePath = path.join(installedClientPath, 'tsconfig.module.json');
    yield compileTs(indexFilePath, version, {
        outDir: dotVendiaClientPath,
        tsconfig: tsconfigModulePath,
        format: ['esm'],
    });
    // Delete typescript source files after compilation
    // (prevent users' tsc/typechecking tooling from complaining about any type errors in there)
    // tsup resolves promise above BEFORE d.ts generation is complete so we have to poll here
    // to make sure index.d.ts file exists before deleting the files
    debugInfo.secondsWaitingForDtsFileGeneration = 0;
    // Spend max of 20 seconds waiting to delete files
    for (let i = 0; i < 20; i++) {
        if (fs.existsSync(typeDefFilePath)) {
            // Success! We can delete the files
            // Add in a brief static delay to make _absolutely_ sure tsup is done
            yield delay(500);
            // Delete all files (not folders) that aren't js/d.ts files
            fs.readdirSync(dotVendiaClientPath, { withFileTypes: true })
                .filter((f) => f.isFile() && !f.name.endsWith('.d.ts') && !f.name.endsWith('.js'))
                .map((f) => {
                debug('Deleting copied TypeScript source file:', f.name);
                fs.unlinkSync(path.join(dotVendiaClientPath, f.name));
            });
            // Done!
            break;
        }
        else {
            // Wait a second and try again
            yield delay(1000);
            debugInfo.secondsWaitingForDtsFileGeneration = i;
        }
    }
    if (debugInfo.secondsWaitingForDtsFileGeneration >= 19) {
        console.log('Waited 20 seconds for d.ts file generation in order to delete copied TypeScript source files, but did not find index.d.ts file. Moving on.');
    }
    console.log('Vendia client generated successfully!');
});
const delay = (ms) => new Promise((res) => setTimeout(res, ms));
function copyFolderSync(from, to) {
    if (!fs.existsSync(to)) {
        fs.mkdirSync(to);
    }
    fs.readdirSync(from).forEach((element) => {
        if (fs.lstatSync(path.join(from, element)).isFile()) {
            fs.copyFileSync(path.join(from, element), path.join(to, element));
        }
        else {
            copyFolderSync(path.join(from, element), path.join(to, element));
        }
    });
}
