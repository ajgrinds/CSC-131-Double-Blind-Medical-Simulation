// We're using an alias is because it gives us a consistent key with which to access the value in
// the query result, simplifies codegen AND UI code (and usage within react-json-schema-form)
// The literal value of the alias also shows up in the UI as the name of the field they're editing
export const SCALAR_VALUE_ALIAS = 'value';
// Underscores aren't allowed in entity names so we're safe to use
//  this simple separator in our generated query names.
// Pattern is <entity>__<operation>, eg query Product__get { ... }
const queryNameSeparator = '__';
/*
 * Possible data shapes for a given entity:
 * 1. top-level array of objects with properties (most common)
 * 2. top-level array of some scalar type (e.g. string, number, boolean) - properties will be null
 * 3. top-level object with properties
 * 4. top-level scalar type - properties will be null
 *
 * These each have slightly different query/mutation formats
 * */
export const topLevelTypes = {
    ARRAY_OF_OBJECTS: 'ARRAY_OF_OBJECTS',
    ARRAY_OF_SCALARS: 'ARRAY_OF_SCALARS',
    OBJECT: 'OBJECT',
    SCALAR: 'SCALAR',
};
function getTopLevelType(value) {
    var _a, _b;
    if (value.type === 'array' && ((_a = value === null || value === void 0 ? void 0 : value.items) === null || _a === void 0 ? void 0 : _a.type) !== 'object') {
        return topLevelTypes.ARRAY_OF_SCALARS;
    }
    if (value.type === 'array' && ((_b = value === null || value === void 0 ? void 0 : value.items) === null || _b === void 0 ? void 0 : _b.type) === 'object') {
        return topLevelTypes.ARRAY_OF_OBJECTS;
    }
    if (value.type === 'object') {
        return topLevelTypes.OBJECT;
    }
    if (value.type === 'string' ||
        value.type === 'number' ||
        value.type === 'boolean' ||
        value.type === 'null' // Technically possible according to JSON schema, but unlikely
    ) {
        return topLevelTypes.SCALAR;
    }
    throw new Error('Unsupported top-level type');
}
export function getEntitiesFromJsonSchema(schema) {
    var _a;
    const entitiesWithAcl = Object.values((_a = schema === null || schema === void 0 ? void 0 : schema['x-vendia-acls']) !== null && _a !== void 0 ? _a : {}).reduce((acc, { type }) => {
        acc[type] = true;
        return acc;
    }, {});
    const entities = {};
    Object.entries(schema.properties).forEach(([name, value]) => {
        var _a, _b, _c, _d;
        entities[name] = {
            type: value.type,
            description: value.description,
            properties: (_c = (_b = (_a = value === null || value === void 0 ? void 0 : value.items) === null || _a === void 0 ? void 0 : _a.properties) !== null && _b !== void 0 ? _b : value === null || value === void 0 ? void 0 : value.properties) !== null && _c !== void 0 ? _c : null,
            hasAcl: (_d = entitiesWithAcl[name]) !== null && _d !== void 0 ? _d : false,
            topLevelType: getTopLevelType(value),
        };
    });
    return entities;
}
export const ALIAS_PREFIX = '__alias__';
export function getResultFields({ properties, aliasFields, insertTypename }) {
    const propertyEntries = Object.entries(properties);
    if (insertTypename) {
        propertyEntries.unshift(['__typename', { type: 'string' }]);
    }
    return propertyEntries.map(([propertyName, propertyValue]) => {
        var _a;
        // aliasFields is used for ACL queries - top-level fields that are required need to be aliased
        // in one of the union sections or else there will be a graphQL error
        // NOTE: we ONLY alias top-level fields, thus not passing this option to recursive calls below!
        let name = aliasFields ? `${ALIAS_PREFIX}${propertyName}: ${propertyName}` : propertyName;
        // Undo that for __typename, don't want to alias that
        if (propertyName === '__typename') {
            name = '__typename';
        }
        if (propertyValue.type === 'array' && ((_a = propertyValue.items) === null || _a === void 0 ? void 0 : _a.type) === 'object') {
            return `${name} {
        ${getResultFields({ properties: propertyValue.items.properties })}
      }`;
        }
        if (propertyValue.type === 'object' && Object.keys(propertyValue === null || propertyValue === void 0 ? void 0 : propertyValue.properties).length > 0) {
            return `${name} {
        ${getResultFields({ properties: propertyValue.properties })}
      }`;
        }
        return name;
    }).join(`
  `);
}
function getResult(entity, entities, schemaNamespace, isTopLevelArrayType) {
    return `{
          ${isTopLevelArrayType ? `_id` : ''}
          _owner
          ${getResultFields({ properties: entities[entity].properties })}
        }`;
}
function getResultForAclEnabled(entity, entities, schemaNamespace, isTopLevelArrayType) {
    return `{
            ... on ${schemaNamespace}_${entity} {
              ${isTopLevelArrayType ? `_id` : ''}
              _owner
              ${getResultFields({ properties: entities[entity].properties })}
            }
            ... on ${schemaNamespace}_${entity}_Partial_ {
              ${isTopLevelArrayType ? `_id` : ''}
              _owner
              ${getResultFields({
        properties: entities[entity].properties,
        aliasFields: true,
    })}
            }
          }`;
}
function getResultForScalarType(entity, schemaNamespace, isTopLevelArrayType) {
    if (!isTopLevelArrayType) {
        return '';
    }
    return `{
            _id
            ${SCALAR_VALUE_ALIAS}: ${schemaNamespace}_${entity}
          }`;
}
export function generateGetOperation({ entity, entities, schemaNamespace }) {
    var _a;
    const topLevelType = (_a = entities === null || entities === void 0 ? void 0 : entities[entity]) === null || _a === void 0 ? void 0 : _a.topLevelType;
    const isTopLevelArray = topLevelType === topLevelTypes.ARRAY_OF_OBJECTS || topLevelType === topLevelTypes.ARRAY_OF_SCALARS;
    const hasAcl = entities[entity].hasAcl;
    let params = isTopLevelArray ? '(id: $id, version: $version)' : '(version: $version)';
    let paramTypes = isTopLevelArray ? '($id: ID!, $version: Int)' : '($version: Int)';
    if (topLevelType === topLevelTypes.SCALAR) {
        params = '';
        paramTypes = '';
    }
    let resultContent;
    if (topLevelType === topLevelTypes.SCALAR || topLevelType === topLevelTypes.ARRAY_OF_SCALARS) {
        resultContent = getResultForScalarType(entity, schemaNamespace, isTopLevelArray);
    }
    else if (hasAcl) {
        resultContent = getResultForAclEnabled(entity, entities, schemaNamespace, isTopLevelArray);
    }
    else {
        resultContent = getResult(entity, entities, schemaNamespace, isTopLevelArray);
    }
    return `
        query ${entity}${queryNameSeparator}get ${paramTypes}{
          get_${entity}${params} ${resultContent}
        }`;
}
function generateGetOperations(entities, schema, schemaNamespace) {
    const queryTemplates = Object.keys(entities).map((entity) => {
        return generateGetOperation({ entity, entities, schema, schemaNamespace });
    });
    return queryTemplates.join('\n\n');
}
export function generateListOperation({ entity, entities, schemaNamespace }) {
    var _a;
    if (entities[entity].topLevelType === topLevelTypes.SCALAR ||
        entities[entity].topLevelType === topLevelTypes.OBJECT) {
        // Skipping list operation for top-level types that aren't arrays
        return;
    }
    const topLevelType = (_a = entities === null || entities === void 0 ? void 0 : entities[entity]) === null || _a === void 0 ? void 0 : _a.topLevelType;
    const hasAcl = entities[entity].hasAcl;
    const filterType = `${schemaNamespace}_${entity}_FilterInput_`;
    const orderType = `[${schemaNamespace}_${entity}_OrderInput_!]`;
    const entityPlural = `_${entity}Items`;
    let resultContent;
    if (topLevelType === topLevelTypes.ARRAY_OF_SCALARS) {
        resultContent = getResultForScalarType(entity, schemaNamespace, true);
    }
    else if (hasAcl) {
        resultContent = getResultForAclEnabled(entity, entities, schemaNamespace, true);
    }
    else {
        resultContent = getResult(entity, entities, schemaNamespace, true);
    }
    return `
          query ${entity}${queryNameSeparator}list($nextToken: String, $limit: Int, $filter: ${filterType}, $order: ${orderType}) {
            list${entityPlural}(nextToken: $nextToken, limit: $limit, filter: $filter, order: $order) {
              ${entityPlural} ${resultContent}
              nextToken
            }
          }`;
}
function generateListOperations(entities, schema, schemaNamespace) {
    const queryTemplates = Object.keys(entities).map((entity) => {
        return generateListOperation({ entity, entities, schema, schemaNamespace });
    });
    return queryTemplates.join('\n\n');
}
/// MUTATION STUFF
const jsonToGglType = {
    number: 'Float',
    string: 'String',
    boolean: 'Boolean',
};
function getTopLevelScalarOrObjectTemplate({ prefix, type, topLevelType, hasAcl, entity, schemaNamespace, entities }) {
    const inputSuffix = prefix === 'create' ? 'Input' : 'UpdateInput';
    const inputType = topLevelType === topLevelTypes.SCALAR ? jsonToGglType[type] : `${schemaNamespace}_${entity}_${inputSuffix}_`;
    const conditionParamType = prefix === 'create' ? '' : `, $condition: ${schemaNamespace}_${entity}_ConditionInput_`;
    const conditionParam = prefix === 'create' ? '' : ', condition: $condition';
    const aclParamType = hasAcl ? `, $aclInput: Vendia_Acls_Input_` : '';
    const aclParam = hasAcl ? ', aclInput: $aclInput' : '';
    let resultContent;
    if (topLevelType === topLevelTypes.SCALAR) {
        resultContent = getResultForScalarType(entity, schemaNamespace, false);
    }
    else if (hasAcl) {
        resultContent = getResultForAclEnabled(entity, entities, schemaNamespace, false);
    }
    else {
        resultContent = getResult(entity, entities, schemaNamespace, false);
    }
    return `mutation ${entity}${queryNameSeparator}${prefix} ($input: ${inputType}!, $syncMode: Vendia_SyncMode = NODE_COMMITTED${conditionParamType}${aclParamType}) {
    ${prefix}_${entity}(input: $input, syncMode: $syncMode${conditionParam}${aclParam}) {
      transaction {
        _id
        _owner
        transactionId
        submissionTime
        version
      }
      result ${resultContent}
    }
  }`;
}
// handle array of scalars
function getTopLevelArrayTemplate({ prefix, type, topLevelType, hasAcl, entity, schemaNamespace, entities }) {
    const inputSuffix = prefix === 'put' || prefix === 'add' ? 'Input' : 'UpdateInput';
    const idParamType = prefix === 'add' ? '' : '$id: ID!,';
    const idParam = prefix === 'add' ? '' : 'id: $id,';
    const inputType = topLevelType === topLevelTypes.ARRAY_OF_SCALARS
        ? jsonToGglType[type]
        : `${schemaNamespace}_${entity}_${inputSuffix}_`;
    const conditionParamType = prefix === 'add' ? '' : `, $condition: ${schemaNamespace}_${entity}_ConditionInput_`;
    const conditionParam = prefix === 'add' ? '' : ', condition: $condition';
    const aclParamType = hasAcl ? `, $aclInput: Vendia_Acls_Input_` : '';
    const aclParam = hasAcl ? ', aclInput: $aclInput' : '';
    let resultContent;
    if (topLevelType === topLevelTypes.ARRAY_OF_SCALARS) {
        resultContent = getResultForScalarType(entity, schemaNamespace, true);
    }
    else if (hasAcl) {
        resultContent = getResultForAclEnabled(entity, entities, schemaNamespace, true);
    }
    else {
        resultContent = getResult(entity, entities, schemaNamespace, true);
    }
    return `mutation ${entity}${queryNameSeparator}${prefix} (${idParamType} $input: ${inputType}!, $syncMode: Vendia_SyncMode = NODE_COMMITTED${conditionParamType}${aclParamType}) {
    ${prefix}_${entity}(${idParam} input: $input, syncMode: $syncMode${conditionParam}${aclParam}) {
      transaction {
        _id
        _owner
        transactionId
        submissionTime
        version
      }
      result ${resultContent}
    }
  }`;
}
function getEntityInfo({ entity, entities, schema }) {
    var _a, _b, _c, _d, _e, _f;
    const topLevelType = (_a = entities === null || entities === void 0 ? void 0 : entities[entity]) === null || _a === void 0 ? void 0 : _a.topLevelType;
    const isTopLevelArray = topLevelType === topLevelTypes.ARRAY_OF_OBJECTS || topLevelType === topLevelTypes.ARRAY_OF_SCALARS;
    const type = isTopLevelArray ? (_d = (_c = (_b = schema === null || schema === void 0 ? void 0 : schema.properties) === null || _b === void 0 ? void 0 : _b[entity]) === null || _c === void 0 ? void 0 : _c.items) === null || _d === void 0 ? void 0 : _d.type : (_f = (_e = schema === null || schema === void 0 ? void 0 : schema.properties) === null || _e === void 0 ? void 0 : _e[entity]) === null || _f === void 0 ? void 0 : _f.type;
    const hasAcl = entities[entity].hasAcl;
    return {
        topLevelType,
        isTopLevelArray,
        type,
        hasAcl,
    };
}
// Add (or Create)
export function generateAddOperation({ entity, entities, schema, schemaNamespace }) {
    const { isTopLevelArray, topLevelType, type, hasAcl } = getEntityInfo({ entity, entities, schema });
    const options = {
        prefix: isTopLevelArray ? 'add' : 'create',
        topLevelType,
        type,
        hasAcl,
        entity,
        entities,
        schemaNamespace,
    };
    return isTopLevelArray ? getTopLevelArrayTemplate(options) : getTopLevelScalarOrObjectTemplate(options);
}
export function generateUpdateOperation({ entity, entities, schema, schemaNamespace }) {
    const { isTopLevelArray, topLevelType, type, hasAcl } = getEntityInfo({ entity, entities, schema });
    const options = {
        prefix: 'update',
        topLevelType,
        type,
        hasAcl,
        entity,
        entities,
        schemaNamespace,
    };
    return isTopLevelArray ? getTopLevelArrayTemplate(options) : getTopLevelScalarOrObjectTemplate(options);
}
function generateCreateUpdateMutations(entities, schema, schemaNamespace) {
    const mutationTemplates = Object.keys(entities).map((entity) => {
        // Skipping put for now, because aclInput requirement makes it tricky... becomes a third, required, option in SDK
        // templates.push(getTopLevelArrayTemplate({ prefix: 'put', type, entity, schemaNamespace, topLevelType,hasAcl }))
        const templates = [
            generateAddOperation({ entity, entities, schema, schemaNamespace }),
            generateUpdateOperation({ entity, entities, schema, schemaNamespace }),
        ];
        return templates.join('\n\n');
    });
    return mutationTemplates.join('\n\n');
}
export function generateDeleteOperation({ entity, entities, schemaNamespace }) {
    const topLevelType = entities[entity].topLevelType;
    const isTopLevelArray = topLevelType === topLevelTypes.ARRAY_OF_OBJECTS || topLevelType === topLevelTypes.ARRAY_OF_SCALARS;
    const operationName = isTopLevelArray ? 'remove' : 'delete';
    const idParamType = !isTopLevelArray ? '' : '$id: ID!,';
    const idParam = !isTopLevelArray ? '' : 'id: $id,';
    return `mutation ${entity}${queryNameSeparator}${operationName} (${idParamType} $syncMode: Vendia_SyncMode = NODE_COMMITTED, $condition: ${schemaNamespace}_${entity}_ConditionInput_) {
    ${operationName}_${entity}(${idParam} syncMode: $syncMode, condition: $condition) {
      transaction {
        _id
        _owner
        transactionId
        submissionTime
        version
      }
    }
  }`;
}
function generateDeleteMutations(entities, schema, schemaNamespace) {
    const mutationTemplates = Object.keys(entities).map((entity) => {
        return generateDeleteOperation({ entity, entities, schema, schemaNamespace });
    });
    return mutationTemplates.join('\n\n');
}
function generateSubscriptions(entities, schema, schemaNamespace) {
    const mutationTemplates = Object.keys(entities).map((entity) => {
        const topLevelType = entities[entity].topLevelType;
        const isTopLevelArray = topLevelType === topLevelTypes.ARRAY_OF_OBJECTS || topLevelType === topLevelTypes.ARRAY_OF_SCALARS;
        let resultContent;
        if (topLevelType === topLevelTypes.SCALAR || topLevelType === topLevelTypes.ARRAY_OF_SCALARS) {
            resultContent = getResultForScalarType(entity, schemaNamespace, isTopLevelArray);
        }
        else {
            resultContent = getResult(entity, entities, schemaNamespace, isTopLevelArray);
        }
        function getSubscriptionTemplate(operationName) {
            // Scalar just returns value, no id or error field - strange, but true
            // Refactor to use getResultForScalarType and merge with ARRAY_OF_SCALARS case below if this ever changes
            if (topLevelType === topLevelTypes.SCALAR) {
                return `subscription ${entity}${queryNameSeparator}on${operationName} {
      on${operationName}_${entity}
    }`;
            }
            // TODO - update if/when we update subscription return types for ACL-enabled entities (no union with partial at the moment)
            return `subscription ${entity}${queryNameSeparator}on${operationName} {
      on${operationName}_${entity} {
        error
        result ${resultContent}
      }
    }`;
        }
        let operations = ['Create', 'Delete', 'Update'];
        if (isTopLevelArray) {
            operations = ['Add', 'Remove', 'Update'];
        }
        return operations.map((operation) => getSubscriptionTemplate(operation)).join('\n\n');
    });
    return mutationTemplates.join('\n\n');
}
export const generateEntityOperations = (schema, schemaNamespace) => {
    const schemaEntities = getEntitiesFromJsonSchema(schema);
    return (generateGetOperations(schemaEntities, schema, schemaNamespace) +
        generateListOperations(schemaEntities, schema, schemaNamespace) +
        generateCreateUpdateMutations(schemaEntities, schema, schemaNamespace) +
        generateDeleteMutations(schemaEntities, schema, schemaNamespace) +
        generateSubscriptions(schemaEntities, schema, schemaNamespace));
};
