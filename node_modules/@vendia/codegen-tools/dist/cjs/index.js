var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  compileTs: () => compileTs,
  generateClient: () => generateClient,
  generateTypescript: () => generateTypescript
});
module.exports = __toCommonJS(src_exports);

// src/compileTypescript.ts
var import_tsup = require("tsup");
var compileTs = async (entry, version, options) => {
  const config = (0, import_tsup.defineConfig)(__spreadValues({
    legacyOutput: true,
    entryPoints: [entry],
    silent: !process.env.VENDIA_DEBUG,
    config: false,
    esbuildOptions(options2) {
      if (options2 && options2.define) {
        options2.define["PACKAGE_VERSION"] = `"${version}"`;
      }
    }
  }, options));
  await (0, import_tsup.build)(config);
};

// src/generateClient.ts
var import_fs = __toESM(require("fs"));
var import_graphql2 = require("graphql");
var import_path = __toESM(require("path"));

// src/generateTypescript.ts
var import_core = require("@graphql-codegen/core");

// src/commonOperations.ts
var operations = `
  query _blocks__get($id: ID!) {
    getVendia_Block(id: $id) {
      _id
      blockSchemaVersion
      blockId
      redactedBlockHash
      previousBlockId
      previousRedactedBlockHash
      blockHash
      previousBlockHash
      status
      commitTime
      _owner
      transactions {
        _id
        hash
        redactedHash
        signature
        version
        submissionTime
        mutations
        _owner
      }
    }
  }

  query _blocks__list($order: [Vendia_Block_OrderInput_!], $filter: Vendia_Block_FilterInput_, $limit: Int, $nextToken: String) {
    listVendia_BlockItems(order: $order, filter: $filter, limit: $limit, nextToken: $nextToken) {
      nextToken
      Vendia_BlockItems {
        _id
        blockSchemaVersion
        blockId
        redactedBlockHash
        previousBlockId
        previousRedactedBlockHash
        blockHash
        previousBlockHash
        status
        commitTime
        _owner
        transactions {
          _id
          hash
          redactedHash
          signature
          version
          submissionTime
          mutations
          _owner
        }
      }
    }
  }

  subscription _blocks__onAdd {
    onAddVendia_Block {
      ...Vendia_Block_Result_Fragment
    }
  }

  fragment Vendia_Block_Result_Fragment on Vendia_Block_Result_ {
    error
    result {
      _id
      blockSchemaVersion
      blockId
      redactedBlockHash
      previousBlockId
      previousRedactedBlockHash
      blockHash
      previousBlockHash
      status
      commitTime
      _owner
      transactions {
        _id
        hash
        redactedHash
        signature
        version
        submissionTime
        mutations
        _owner
      }
    }
  }

  query _contracts__get($id: ID!, $version: Int) {
    getVendia_Contract(id: $id, version: $version) {
      ... on Vendia_Contract {
        description
        revisionId
        _acl {
          path
          operations
          principal {
            nodes
          }
        }
        _id
        _owner
        inputQuery
        name
        outputMutation
        resource {
          uri
          csp
          metadata {
            name
            value
          }
        }
      }
      ... on Vendia_Contract_Partial_ {
        __alias__name: name
        description
        _acl {
          path
          operations
          principal {
            nodes
          }
        }
        _id
        _owner
        inputQuery
        __alias__outputMutation: outputMutation
        __alias__resource: resource {
          uri
          csp
          metadata {
            name
            value
          }
        }
        revisionId
      }
    }
  }

  query _contracts__list($limit: Int, $nextToken: String, $order: [Vendia_Contract_OrderInput_!], $filter: Vendia_Contract_FilterInput_) {
    listVendia_ContractItems(order: $order, filter: $filter, limit: $limit, nextToken: $nextToken) {
      Vendia_ContractItems {
        ... on Vendia_Contract {
          description
          revisionId
          _acl {
            path
            operations
            principal {
              nodes
            }
          }
          _id
          _owner
          inputQuery
          name
          outputMutation
          resource {
            uri
            csp
            metadata {
              name
              value
            }
          }
        }
        ... on Vendia_Contract_Partial_ {
          __alias__name: name
          description
          _acl {
            path
            operations
            principal {
              nodes
            }
          }
          _id
          _owner
          inputQuery
          __alias__outputMutation: outputMutation
          __alias__resource: resource {
            uri
            csp
            metadata {
              name
              value
            }
          }
          revisionId
        }
      }
      nextToken
    }
  }

  query _contracts__listVersions($id: ID!, $limit: Int, $nextToken: String) {
    listVendia_ContractVersions(id: $id, limit: $limit, nextToken: $nextToken) {
      nextToken
      versions {
        ordinal
        block
        transactions {
          _id
          _owner
          submissionTime
        }
      }
    }
  }

  mutation _contracts__add(
    $aclInput: Vendia_Acls_Input_
    $input: Vendia_Contract_Input_!
    $syncMode: Vendia_SyncMode = NODE_COMMITTED
  ) {
    addVendia_Contract(aclInput: $aclInput, input: $input, syncMode: $syncMode) {
      transaction {
        _id
        transactionId
        version
        submissionTime
        _owner
      }
      result {
        ... on Vendia_Contract {
          description
          revisionId
          _acl {
            operations
            path
            principal {
              nodes
            }
          }
          _id
          _owner
          inputQuery
          name
          outputMutation
          resource {
            uri
            csp
            metadata {
              name
              value
            }
          }
        }
        ... on Vendia_Contract_Partial_ {
          __alias__name: name
          description
          _acl {
            path
            operations
            principal {
              nodes
            }
          }
          _id
          _owner
          inputQuery
          __alias__outputMutation: outputMutation
          __alias__resource: resource {
            uri
            csp
            metadata {
              name
              value
            }
          }
          revisionId
        }
      }
    }
  }

  mutation _contracts__update(
    $id: ID!
    $aclInput: Vendia_Acls_Input_
    $condition: Vendia_Contract_ConditionInput_
    $input: Vendia_Contract_UpdateInput_ = {}
    $syncMode: Vendia_SyncMode = NODE_COMMITTED
  ) {
    updateVendia_Contract(input: $input, aclInput: $aclInput, condition: $condition, id: $id, syncMode: $syncMode) {
      transaction {
        _id
        transactionId
        version
        submissionTime
        _owner
      }
      result {
        ... on Vendia_Contract {
          description
          revisionId
          _acl {
            operations
            path
            principal {
              nodes
            }
          }
          _id
          _owner
          inputQuery
          name
          outputMutation
          resource {
            uri
            csp
            metadata {
              name
              value
            }
          }
        }
        ... on Vendia_Contract_Partial_ {
          __alias__name: name
          description
          _acl {
            path
            operations
            principal {
              nodes
            }
          }
          _id
          _owner
          inputQuery
          __alias__outputMutation: outputMutation
          __alias__resource: resource {
            uri
            csp
            metadata {
              name
              value
            }
          }
          revisionId
        }
      }
    }
  }

  mutation _contracts__invoke($input: Vendia_Contract_InvokeInput_, $revisionId: String, $id: ID!) {
    invokeVendia_Contract(id: $id, input: $input, revisionId: $revisionId, syncMode: ASYNC) {
      transaction {
        _id
        transactionId
        version
        submissionTime
        _owner
      }
    }
  }

  mutation _contracts__remove(
    $id: ID!
    $condition: Vendia_Contract_ConditionInput_
    $syncMode: Vendia_SyncMode = NODE_COMMITTED
  ) {
    removeVendia_Contract(id: $id, condition: $condition, syncMode: $syncMode) {
      transaction {
        _id
        transactionId
        version
        submissionTime
        _owner
      }
    }
  }

  query _deployments__get($id: ID!) {
    getVendia_DeploymentInfo(id: $id) {
      _id
      deploymentTime
      consensusDefinitionHash
      versionTag
      _owner
    }
  }

  query _deployments__list($order: [Vendia_DeploymentInfo_OrderInput_!], $filter: Vendia_DeploymentInfo_FilterInput_, $nextToken: String, $limit: Int) {
    listVendia_DeploymentInfoItems(order: $order, filter: $filter, limit: $limit, nextToken: $nextToken) {
      Vendia_DeploymentInfoItems {
        _id
        deploymentTime
        consensusDefinitionHash
        versionTag
        _owner
      }
      nextToken
    }
  }

  query _files__get($id: ID!, $version: Int) {
    getVendia_File(id: $id, version: $version) {
      _id
      sourceBucket
      sourceKey
      sourceRegion
      sourceVersion
      destinationKey
      copyStrategy
      read
      write
      etag
      createdTime
      updatedTime
      temporaryUrl
      fileVersion
      _owner
    }
  }

  query _files__list($order: [Vendia_File_OrderInput_!], $filter: Vendia_File_FilterInput_, $limit: Int, $nextToken: String) {
    listVendia_FileItems(order: $order, filter: $filter, limit: $limit, nextToken: $nextToken) {
      nextToken
      Vendia_FileItems {
        _id
        sourceBucket
        sourceKey
        sourceRegion
        sourceVersion
        destinationKey
        copyStrategy
        read
        write
        etag
        createdTime
        updatedTime
        temporaryUrl
        fileVersion
        _owner
      }
    }
  }

  query _files__listVersions($id: ID!, $limit: Int, $nextToken: String) {
    listVendia_FileVersions(id: $id, limit: $limit, nextToken: $nextToken) {
      nextToken
      versions {
        ordinal
        block
        transactions {
          _id
          _owner
          submissionTime
        }
      }
    }
  }

  mutation _files__add($input: Vendia_File_Input_!, $syncMode: Vendia_SyncMode = NODE_COMMITTED) {
    addVendia_File(input: $input, syncMode: $syncMode) {
      transaction {
        _id
        transactionId
        version
        submissionTime
        _owner
      }
      result {
        _id
        sourceBucket
        sourceKey
        sourceRegion
        sourceVersion
        destinationKey
        copyStrategy
        read
        write
        etag
        createdTime
        updatedTime
        temporaryUrl
        fileVersion
        _owner
      }
    }
  }

  mutation _files__update(
    $id: ID!
    $condition: Vendia_File_ConditionInput_
    $input: Vendia_File_UpdateInput_!
    $syncMode: Vendia_SyncMode = NODE_COMMITTED
  ) {
    updateVendia_File(id: $id, input: $input, condition: $condition, syncMode: $syncMode) {
      transaction {
        _id
        transactionId
        version
        submissionTime
        _owner
      }
      result {
        _id
        sourceBucket
        sourceKey
        sourceRegion
        sourceVersion
        destinationKey
        copyStrategy
        read
        write
        etag
        createdTime
        updatedTime
        temporaryUrl
        fileVersion
        _owner
      }
    }
  }

  mutation _files__remove(
    $condition: Vendia_File_ConditionInput_
    $id: ID!
    $syncMode: Vendia_SyncMode = NODE_COMMITTED
  ) {
    removeVendia_File(id: $id, condition: $condition, syncMode: $syncMode) {
      transaction {
        _id
        transactionId
        version
        submissionTime
        _owner
      }
    }
  }

  subscription _files__onAdd {
    onAddVendia_File {
      ...Vendia_File_Result_Fragment
    }
  }

  subscription _files__onRemove {
    onRemoveVendia_File {
      ...Vendia_File_Result_Fragment
    }
  }

  subscription _files__onUpdate {
    onUpdateVendia_File {
      ...Vendia_File_Result_Fragment
    }
  }

  fragment Vendia_File_Result_Fragment on Vendia_File_Result_ {
    error
    result {
      _id
      sourceBucket
      sourceKey
      sourceRegion
      sourceVersion
      destinationKey
      copyStrategy
      read
      write
      etag
      createdTime
      updatedTime
      temporaryUrl
      fileVersion
      _owner
    }
  }

  query _folders__get($id: ID!, $version: Int) {
    getVendia_Folder(id: $id, version: $version) {
      _id
      name
      parent
      read
      write
      copyStrategy
      createdTime
      updatedTime
      _owner
    }
  }

  query _folders__list($order: [Vendia_Folder_OrderInput_!], $filter: Vendia_Folder_FilterInput_, $limit: Int, $nextToken: String) {
    listVendia_FolderItems(order: $order, filter: $filter, limit: $limit, nextToken: $nextToken) {
      Vendia_FolderItems {
        _id
        name
        parent
        read
        write
        copyStrategy
        createdTime
        updatedTime
        _owner
      }
      nextToken
    }
  }

  query _folders__listVersions($id: ID!, $limit: Int, $nextToken: String) {
    listVendia_FolderVersions(id: $id, limit: $limit, nextToken: $nextToken) {
      nextToken
      versions {
        ordinal
        block
        transactions {
          _id
          _owner
          submissionTime
        }
      }
    }
  }

  mutation _folders__add($input: Vendia_Folder_Input_!, $syncMode: Vendia_SyncMode = NODE_COMMITTED) {
    addVendia_Folder(input: $input, syncMode: $syncMode) {
      transaction {
        _id
        transactionId
        version
        submissionTime
        _owner
      }
      result {
        _id
        name
        parent
        read
        write
        copyStrategy
        createdTime
        updatedTime
        _owner
      }
    }
  }

  mutation _folders__remove(
    $id: ID!
    $condition: Vendia_Folder_ConditionInput_
    $syncMode: Vendia_SyncMode = NODE_COMMITTED
  ) {
    removeVendia_Folder(id: $id, condition: $condition, syncMode: $syncMode) {
      transaction {
        _id
        transactionId
        version
        submissionTime
        _owner
      }
    }
  }

  subscription _folders__onAdd {
    onAddVendia_Folder {
      ...Vendia_Folder_Result_Fragment
    }
  }

  subscription _folders__onRemove {
    onRemoveVendia_Folder {
      ...Vendia_Folder_Result_Fragment
    }
  }

  subscription _folders__onUpdate {
    onUpdateVendia_Folder {
      ...Vendia_Folder_Result_Fragment
    }
  }

  fragment Vendia_Folder_Result_Fragment on Vendia_Folder_Result_ {
    error
    result {
      _id
      name
      parent
      read
      write
      copyStrategy
      createdTime
      updatedTime
      _owner
    }
  }

  query _settings__get($version: Int) {
    getVendia_Settings(version: $version) {
      blockReportWebhooks
      blockReportEmails
      deadLetterWebhooks
      deadLetterEmails
      azure {
        defaultSubscriptionId
        defaultTenantId
      }
      resourceMapKeys
      resourceMapValues
      apiSettings {
        apiKeys {
          value
          usagePlan {
            quotaSettings {
              limit
              offset
              period
            }
            throttleSettings {
              burstLimit
              rateLimit
            }
          }
        }
        auth {
          authorizerType
          authorizerArn
          allowedAccounts
        }
      }
      _owner
      aws {
        blockReportSQSQueues
        blockReportLambdas
        blockReportFirehoses
        deadLetterSQSQueues
        deadLetterLambdas
        s3ReadAccounts
        dataDogMonitoring {
          ddExternalId
          ddApiKey
          ddLogEndpoint
          ddSendLogs
        }
      }
    }
  }

  query _settings__listVersions($limit: Int, $nextToken: String) {
    listVendia_SettingsVersions(limit: $limit, nextToken: $nextToken) {
      versions {
        ordinal
        block
        transactions {
          _id
          _owner
          submissionTime
        }
      }
      nextToken
    }
  }

  mutation _settings__update(
    $condition: Vendia_Settings_ConditionInput_
    $input: Vendia_Settings_UpdateInput_!
    $syncMode: Vendia_SyncMode = NODE_COMMITTED
  ) {
    updateVendia_Settings(condition: $condition, input: $input, syncMode: $syncMode) {
      transaction {
        _id
        transactionId
        version
        submissionTime
        _owner
      }
      result {
        blockReportWebhooks
        blockReportEmails
        deadLetterWebhooks
        deadLetterEmails
        azure {
          blockReportFunctions {
            resourceGroupName
            functionAppName
            functionName
          }
          blockReportQueues {
            resourceGroupName
            storageAccountName
            queueName
          }
          deadLetterFunctions {
            resourceGroupName
            functionAppName
            functionName
          }
          deadLetterQueues {
            resourceGroupName
            storageAccountName
            queueName
          }
          defaultSubscriptionId
          defaultTenantId
        }
        resourceMapKeys
        resourceMapValues
        apiSettings {
          apiKeys {
            value
            usagePlan {
              quotaSettings {
                limit
                offset
                period
              }
              throttleSettings {
                burstLimit
                rateLimit
              }
            }
          }
        }
        _owner
        aws {
          blockReportSQSQueues
          blockReportLambdas
          blockReportFirehoses
          deadLetterSQSQueues
          deadLetterLambdas
          s3ReadAccounts
          dataDogMonitoring {
            ddExternalId
            ddApiKey
            ddLogEndpoint
            ddSendLogs
          }
        }
      }
    }
  }

  query _uniInfo__get {
    getVendia_UniInfo {
      name
      sku
      schema
      schemaNamespace
      status
      createdTime
      updatedTime
      localNodeName
      _owner
      nodes {
        name
        userId
        userEmail
        description
        status
        csp
        region
        bucketName
        temporaryCredentials {
          uploadFile {
            accessKeyId
            expiration
            secretAccessKey
            sessionToken
          }
        }
        tier {
          share
        }
        vendiaAccount {
          csp
          accountId
          userId
          org
        }
      }
    }
  }
`;

// src/entityOperations.js
var SCALAR_VALUE_ALIAS = "value";
var queryNameSeparator = "__";
var topLevelTypes = {
  ARRAY_OF_OBJECTS: "ARRAY_OF_OBJECTS",
  ARRAY_OF_SCALARS: "ARRAY_OF_SCALARS",
  OBJECT: "OBJECT",
  SCALAR: "SCALAR"
};
function getTopLevelType(value) {
  var _a, _b;
  if (value.type === "array" && ((_a = value == null ? void 0 : value.items) == null ? void 0 : _a.type) !== "object") {
    return topLevelTypes.ARRAY_OF_SCALARS;
  }
  if (value.type === "array" && ((_b = value == null ? void 0 : value.items) == null ? void 0 : _b.type) === "object") {
    return topLevelTypes.ARRAY_OF_OBJECTS;
  }
  if (value.type === "object") {
    return topLevelTypes.OBJECT;
  }
  if (value.type === "string" || value.type === "number" || value.type === "boolean" || value.type === "null") {
    return topLevelTypes.SCALAR;
  }
  throw new Error("Unsupported top-level type");
}
function getEntitiesFromJsonSchema(schema) {
  var _a;
  const entitiesWithAcl = Object.values((_a = schema == null ? void 0 : schema["x-vendia-acls"]) != null ? _a : {}).reduce((acc, { type }) => {
    acc[type] = true;
    return acc;
  }, {});
  const entities = {};
  Object.entries(schema.properties).forEach(([name, value]) => {
    var _a2, _b, _c, _d;
    entities[name] = {
      type: value.type,
      description: value.description,
      properties: (_c = (_b = (_a2 = value == null ? void 0 : value.items) == null ? void 0 : _a2.properties) != null ? _b : value == null ? void 0 : value.properties) != null ? _c : null,
      hasAcl: (_d = entitiesWithAcl[name]) != null ? _d : false,
      topLevelType: getTopLevelType(value)
    };
  });
  return entities;
}
var ALIAS_PREFIX = "__alias__";
function getResultFields({ properties, aliasFields, insertTypename }) {
  const propertyEntries = Object.entries(properties);
  if (insertTypename) {
    propertyEntries.unshift(["__typename", { type: "string" }]);
  }
  return propertyEntries.map(([propertyName, propertyValue]) => {
    var _a;
    let name = aliasFields ? `${ALIAS_PREFIX}${propertyName}: ${propertyName}` : propertyName;
    if (propertyName === "__typename") {
      name = "__typename";
    }
    if (propertyValue.type === "array" && ((_a = propertyValue.items) == null ? void 0 : _a.type) === "object") {
      return `${name} {
        ${getResultFields({ properties: propertyValue.items.properties })}
      }`;
    }
    if (propertyValue.type === "object" && Object.keys(propertyValue == null ? void 0 : propertyValue.properties).length > 0) {
      return `${name} {
        ${getResultFields({ properties: propertyValue.properties })}
      }`;
    }
    return name;
  }).join(`
  `);
}
function getResult(entity, entities, schemaNamespace, isTopLevelArrayType) {
  return `{
          ${isTopLevelArrayType ? `_id` : ""}
          _owner
          ${getResultFields({ properties: entities[entity].properties })}
        }`;
}
function getResultForAclEnabled(entity, entities, schemaNamespace, isTopLevelArrayType) {
  return `{
            ... on ${schemaNamespace}_${entity} {
              ${isTopLevelArrayType ? `_id` : ""}
              _owner
              ${getResultFields({ properties: entities[entity].properties })}
            }
            ... on ${schemaNamespace}_${entity}_Partial_ {
              ${isTopLevelArrayType ? `_id` : ""}
              _owner
              ${getResultFields({
    properties: entities[entity].properties,
    aliasFields: true
  })}
            }
          }`;
}
function getResultForScalarType(entity, schemaNamespace, isTopLevelArrayType) {
  if (!isTopLevelArrayType) {
    return "";
  }
  return `{
            _id
            ${SCALAR_VALUE_ALIAS}: ${schemaNamespace}_${entity}
          }`;
}
function generateGetOperation({ entity, entities, schemaNamespace }) {
  var _a;
  const topLevelType = (_a = entities == null ? void 0 : entities[entity]) == null ? void 0 : _a.topLevelType;
  const isTopLevelArray = topLevelType === topLevelTypes.ARRAY_OF_OBJECTS || topLevelType === topLevelTypes.ARRAY_OF_SCALARS;
  const hasAcl = entities[entity].hasAcl;
  let params = isTopLevelArray ? "(id: $id, version: $version)" : "(version: $version)";
  let paramTypes = isTopLevelArray ? "($id: ID!, $version: Int)" : "($version: Int)";
  if (topLevelType === topLevelTypes.SCALAR) {
    params = "";
    paramTypes = "";
  }
  let resultContent;
  if (topLevelType === topLevelTypes.SCALAR || topLevelType === topLevelTypes.ARRAY_OF_SCALARS) {
    resultContent = getResultForScalarType(entity, schemaNamespace, isTopLevelArray);
  } else if (hasAcl) {
    resultContent = getResultForAclEnabled(entity, entities, schemaNamespace, isTopLevelArray);
  } else {
    resultContent = getResult(entity, entities, schemaNamespace, isTopLevelArray);
  }
  return `
        query ${entity}${queryNameSeparator}get ${paramTypes}{
          get_${entity}${params} ${resultContent}
        }`;
}
function generateGetOperations(entities, schema, schemaNamespace) {
  const queryTemplates = Object.keys(entities).map((entity) => {
    return generateGetOperation({ entity, entities, schema, schemaNamespace });
  });
  return queryTemplates.join("\n\n");
}
function generateListOperation({ entity, entities, schemaNamespace }) {
  var _a;
  if (entities[entity].topLevelType === topLevelTypes.SCALAR || entities[entity].topLevelType === topLevelTypes.OBJECT) {
    return;
  }
  const topLevelType = (_a = entities == null ? void 0 : entities[entity]) == null ? void 0 : _a.topLevelType;
  const hasAcl = entities[entity].hasAcl;
  const filterType = `${schemaNamespace}_${entity}_FilterInput_`;
  const orderType = `[${schemaNamespace}_${entity}_OrderInput_!]`;
  const entityPlural = `_${entity}Items`;
  let resultContent;
  if (topLevelType === topLevelTypes.ARRAY_OF_SCALARS) {
    resultContent = getResultForScalarType(entity, schemaNamespace, true);
  } else if (hasAcl) {
    resultContent = getResultForAclEnabled(entity, entities, schemaNamespace, true);
  } else {
    resultContent = getResult(entity, entities, schemaNamespace, true);
  }
  return `
          query ${entity}${queryNameSeparator}list($nextToken: String, $limit: Int, $filter: ${filterType}, $order: ${orderType}) {
            list${entityPlural}(nextToken: $nextToken, limit: $limit, filter: $filter, order: $order) {
              ${entityPlural} ${resultContent}
              nextToken
            }
          }`;
}
function generateListOperations(entities, schema, schemaNamespace) {
  const queryTemplates = Object.keys(entities).map((entity) => {
    return generateListOperation({ entity, entities, schema, schemaNamespace });
  });
  return queryTemplates.join("\n\n");
}
var jsonToGglType = {
  number: "Float",
  string: "String",
  boolean: "Boolean"
};
function getTopLevelScalarOrObjectTemplate({ prefix, type, topLevelType, hasAcl, entity, schemaNamespace, entities }) {
  const inputSuffix = prefix === "create" ? "Input" : "UpdateInput";
  const inputType = topLevelType === topLevelTypes.SCALAR ? jsonToGglType[type] : `${schemaNamespace}_${entity}_${inputSuffix}_`;
  const conditionParamType = prefix === "create" ? "" : `, $condition: ${schemaNamespace}_${entity}_ConditionInput_`;
  const conditionParam = prefix === "create" ? "" : ", condition: $condition";
  const aclParamType = hasAcl ? `, $aclInput: Vendia_Acls_Input_` : "";
  const aclParam = hasAcl ? ", aclInput: $aclInput" : "";
  let resultContent;
  if (topLevelType === topLevelTypes.SCALAR) {
    resultContent = getResultForScalarType(entity, schemaNamespace, false);
  } else if (hasAcl) {
    resultContent = getResultForAclEnabled(entity, entities, schemaNamespace, false);
  } else {
    resultContent = getResult(entity, entities, schemaNamespace, false);
  }
  return `mutation ${entity}${queryNameSeparator}${prefix} ($input: ${inputType}!, $syncMode: Vendia_SyncMode = NODE_COMMITTED${conditionParamType}${aclParamType}) {
    ${prefix}_${entity}(input: $input, syncMode: $syncMode${conditionParam}${aclParam}) {
      transaction {
        _id
        _owner
        transactionId
        submissionTime
        version
      }
      result ${resultContent}
    }
  }`;
}
function getTopLevelArrayTemplate({ prefix, type, topLevelType, hasAcl, entity, schemaNamespace, entities }) {
  const inputSuffix = prefix === "put" || prefix === "add" ? "Input" : "UpdateInput";
  const idParamType = prefix === "add" ? "" : "$id: ID!,";
  const idParam = prefix === "add" ? "" : "id: $id,";
  const inputType = topLevelType === topLevelTypes.ARRAY_OF_SCALARS ? jsonToGglType[type] : `${schemaNamespace}_${entity}_${inputSuffix}_`;
  const conditionParamType = prefix === "add" ? "" : `, $condition: ${schemaNamespace}_${entity}_ConditionInput_`;
  const conditionParam = prefix === "add" ? "" : ", condition: $condition";
  const aclParamType = hasAcl ? `, $aclInput: Vendia_Acls_Input_` : "";
  const aclParam = hasAcl ? ", aclInput: $aclInput" : "";
  let resultContent;
  if (topLevelType === topLevelTypes.ARRAY_OF_SCALARS) {
    resultContent = getResultForScalarType(entity, schemaNamespace, true);
  } else if (hasAcl) {
    resultContent = getResultForAclEnabled(entity, entities, schemaNamespace, true);
  } else {
    resultContent = getResult(entity, entities, schemaNamespace, true);
  }
  return `mutation ${entity}${queryNameSeparator}${prefix} (${idParamType} $input: ${inputType}!, $syncMode: Vendia_SyncMode = NODE_COMMITTED${conditionParamType}${aclParamType}) {
    ${prefix}_${entity}(${idParam} input: $input, syncMode: $syncMode${conditionParam}${aclParam}) {
      transaction {
        _id
        _owner
        transactionId
        submissionTime
        version
      }
      result ${resultContent}
    }
  }`;
}
function getEntityInfo({ entity, entities, schema }) {
  var _a, _b, _c, _d, _e, _f;
  const topLevelType = (_a = entities == null ? void 0 : entities[entity]) == null ? void 0 : _a.topLevelType;
  const isTopLevelArray = topLevelType === topLevelTypes.ARRAY_OF_OBJECTS || topLevelType === topLevelTypes.ARRAY_OF_SCALARS;
  const type = isTopLevelArray ? (_d = (_c = (_b = schema == null ? void 0 : schema.properties) == null ? void 0 : _b[entity]) == null ? void 0 : _c.items) == null ? void 0 : _d.type : (_f = (_e = schema == null ? void 0 : schema.properties) == null ? void 0 : _e[entity]) == null ? void 0 : _f.type;
  const hasAcl = entities[entity].hasAcl;
  return {
    topLevelType,
    isTopLevelArray,
    type,
    hasAcl
  };
}
function generateAddOperation({ entity, entities, schema, schemaNamespace }) {
  const { isTopLevelArray, topLevelType, type, hasAcl } = getEntityInfo({ entity, entities, schema });
  const options = {
    prefix: isTopLevelArray ? "add" : "create",
    topLevelType,
    type,
    hasAcl,
    entity,
    entities,
    schemaNamespace
  };
  return isTopLevelArray ? getTopLevelArrayTemplate(options) : getTopLevelScalarOrObjectTemplate(options);
}
function generateUpdateOperation({ entity, entities, schema, schemaNamespace }) {
  const { isTopLevelArray, topLevelType, type, hasAcl } = getEntityInfo({ entity, entities, schema });
  const options = {
    prefix: "update",
    topLevelType,
    type,
    hasAcl,
    entity,
    entities,
    schemaNamespace
  };
  return isTopLevelArray ? getTopLevelArrayTemplate(options) : getTopLevelScalarOrObjectTemplate(options);
}
function generateCreateUpdateMutations(entities, schema, schemaNamespace) {
  const mutationTemplates = Object.keys(entities).map((entity) => {
    const templates = [
      generateAddOperation({ entity, entities, schema, schemaNamespace }),
      generateUpdateOperation({ entity, entities, schema, schemaNamespace })
    ];
    return templates.join("\n\n");
  });
  return mutationTemplates.join("\n\n");
}
function generateDeleteOperation({ entity, entities, schemaNamespace }) {
  const topLevelType = entities[entity].topLevelType;
  const isTopLevelArray = topLevelType === topLevelTypes.ARRAY_OF_OBJECTS || topLevelType === topLevelTypes.ARRAY_OF_SCALARS;
  const operationName = isTopLevelArray ? "remove" : "delete";
  const idParamType = !isTopLevelArray ? "" : "$id: ID!,";
  const idParam = !isTopLevelArray ? "" : "id: $id,";
  return `mutation ${entity}${queryNameSeparator}${operationName} (${idParamType} $syncMode: Vendia_SyncMode = NODE_COMMITTED, $condition: ${schemaNamespace}_${entity}_ConditionInput_) {
    ${operationName}_${entity}(${idParam} syncMode: $syncMode, condition: $condition) {
      transaction {
        _id
        _owner
        transactionId
        submissionTime
        version
      }
    }
  }`;
}
function generateDeleteMutations(entities, schema, schemaNamespace) {
  const mutationTemplates = Object.keys(entities).map((entity) => {
    return generateDeleteOperation({ entity, entities, schema, schemaNamespace });
  });
  return mutationTemplates.join("\n\n");
}
function generateSubscriptions(entities, schema, schemaNamespace) {
  const mutationTemplates = Object.keys(entities).map((entity) => {
    const topLevelType = entities[entity].topLevelType;
    const isTopLevelArray = topLevelType === topLevelTypes.ARRAY_OF_OBJECTS || topLevelType === topLevelTypes.ARRAY_OF_SCALARS;
    let resultContent;
    if (topLevelType === topLevelTypes.SCALAR || topLevelType === topLevelTypes.ARRAY_OF_SCALARS) {
      resultContent = getResultForScalarType(entity, schemaNamespace, isTopLevelArray);
    } else {
      resultContent = getResult(entity, entities, schemaNamespace, isTopLevelArray);
    }
    function getSubscriptionTemplate(operationName) {
      if (topLevelType === topLevelTypes.SCALAR) {
        return `subscription ${entity}${queryNameSeparator}on${operationName} {
      on${operationName}_${entity}
    }`;
      }
      return `subscription ${entity}${queryNameSeparator}on${operationName} {
      on${operationName}_${entity} {
        error
        result ${resultContent}
      }
    }`;
    }
    let operations2 = ["Create", "Delete", "Update"];
    if (isTopLevelArray) {
      operations2 = ["Add", "Remove", "Update"];
    }
    return operations2.map((operation) => getSubscriptionTemplate(operation)).join("\n\n");
  });
  return mutationTemplates.join("\n\n");
}
var generateEntityOperations = (schema, schemaNamespace) => {
  const schemaEntities = getEntitiesFromJsonSchema(schema);
  return generateGetOperations(schemaEntities, schema, schemaNamespace) + generateListOperations(schemaEntities, schema, schemaNamespace) + generateCreateUpdateMutations(schemaEntities, schema, schemaNamespace) + generateDeleteMutations(schemaEntities, schema, schemaNamespace) + generateSubscriptions(schemaEntities, schema, schemaNamespace);
};

// src/generateTypescript.ts
var import_graphql = require("graphql");
var import_json_schema_ref_parser = __toESM(require("@apidevtools/json-schema-ref-parser"));
var generateTypescript = async function({ graphQlSchema, schemaJson, schemaNamespace }) {
  const dereferencedSchema = await import_json_schema_ref_parser.default.dereference(schemaJson, { dereference: { circular: false } });
  const entityOperations = generateEntityOperations(dereferencedSchema, schemaNamespace);
  const allOperations = operations + entityOperations;
  const plugins = [
    {
      typescript: {
        enumsAsTypes: true
      }
    },
    {
      typescriptOperations: {
        arrayInputCoercion: true
      }
    },
    {
      vendiaClientPlugin: {
        schemaNamespace,
        schemaJson: dereferencedSchema
      }
    }
  ];
  const config = {
    documents: [{ document: (0, import_graphql.parse)(allOperations) }],
    config: {
      namingConvention: "keep"
    },
    filename: "generated.ts",
    schema: (0, import_graphql.parse)((0, import_graphql.printSchema)(graphQlSchema)),
    plugins,
    pluginMap: {
      typescript: await Promise.resolve().then(() => __toESM(require("@graphql-codegen/typescript"))),
      typescriptOperations: await Promise.resolve().then(() => __toESM(require("@graphql-codegen/typescript-operations"))),
      vendiaClientPlugin: await Promise.resolve().then(() => __toESM(require("@vendia/codegen-vendia-client-plugin")))
    }
  };
  return (0, import_core.codegen)(config);
};

// src/generateClient.ts
var generateClient = async ({
  dotVendiaDirPath,
  debugInfo = {},
  debug = function() {
  },
  vendiaMonorepoOverrides,
  version
}) => {
  debug("dotVendiaDirPath from generateClient.ts", dotVendiaDirPath);
  debugInfo.dotVendiaDirPath = dotVendiaDirPath;
  const dotVendiaExists = import_fs.default.existsSync(dotVendiaDirPath);
  let graphQlSchema;
  let schemaJson;
  let schemaNamespace;
  if (!dotVendiaExists) {
    console.log(`Could not find .vendia directory \u2014 make sure you've run the client:pull command and you're running generate from the root of your project (the same directory as your package.json).`);
    console.log(`Falling back to a generic schema \u2014 the generated client will not contain "entities".`);
    schemaNamespace = "Self";
    schemaJson = {
      $schema: "http://json-schema.org/draft-07/schema#",
      title: "Uni Schema",
      description: "Empty Uni Schema",
      type: "object",
      properties: {}
    };
    const graphQlString = import_fs.default.readFileSync(import_path.default.join(__dirname, "generic-schema.graphql"), "utf8");
    graphQlSchema = (0, import_graphql2.buildSchema)(graphQlString);
  } else {
    debug("generateClient: dotVendiaDirPath found at", dotVendiaDirPath);
    let schemaJsonString;
    try {
      schemaJsonString = import_fs.default.readFileSync(import_path.default.join(dotVendiaDirPath, "schema.json"), "utf8");
    } catch (e) {
      throw new Error(`Could not find schema.json at ${import_path.default.join(dotVendiaDirPath, "schema.json")}.`);
    }
    try {
      schemaJson = JSON.parse(schemaJsonString);
    } catch (e) {
      throw new Error(`Could not parse schema.json at ${import_path.default.join(dotVendiaDirPath, "schema.json")}.`);
    }
    if (!(schemaJson == null ? void 0 : schemaJson.properties)) {
      throw new Error('schemaJson must be an object with a "properties" field.');
    }
    let configString;
    try {
      configString = import_fs.default.readFileSync(import_path.default.join(dotVendiaDirPath, "config.json"), "utf8");
    } catch (e) {
      throw new Error(`Could not find config.json at ${import_path.default.join(dotVendiaDirPath, "config.json")}.`);
    }
    let config;
    try {
      config = JSON.parse(configString);
      schemaNamespace = config.schemaNamespace;
    } catch (e) {
      throw new Error(`Could not parse config.json at ${import_path.default.join(dotVendiaDirPath, "config.json")}.`);
    }
    if (typeof schemaNamespace !== "string") {
      throw new TypeError("schemaNamespace must be a string.");
    }
    let graphQLString;
    try {
      graphQLString = import_fs.default.readFileSync(import_path.default.join(dotVendiaDirPath, "schema.graphql"), "utf8");
    } catch (e) {
      throw new Error(`Could not find schema.graphql at ${import_path.default.join(dotVendiaDirPath, "schema.graphql")}.`);
    }
    graphQlSchema = (0, import_graphql2.buildSchema)(graphQLString);
  }
  let dotVendiaClientPath;
  let installedClientPath;
  if (vendiaMonorepoOverrides) {
    dotVendiaClientPath = vendiaMonorepoOverrides.dotVendiaClientPath;
    if (!import_fs.default.existsSync(dotVendiaClientPath)) {
      import_fs.default.mkdirSync(dotVendiaClientPath);
    }
    installedClientPath = vendiaMonorepoOverrides.installedClientPath;
  } else {
    const nodeModulesPath = import_path.default.join(dotVendiaDirPath, "..", "node_modules");
    if (!import_fs.default.existsSync(nodeModulesPath)) {
      throw new Error(`Could not find node_modules dir at ${nodeModulesPath} - make sure you've installed the @vendia/client package before running the generate command.`);
    }
    dotVendiaClientPath = import_path.default.join(nodeModulesPath, ".vendia-client");
    if (!import_fs.default.existsSync(dotVendiaClientPath)) {
      import_fs.default.mkdirSync(dotVendiaClientPath);
    }
    installedClientPath = import_path.default.join(dotVendiaDirPath, "..", "node_modules", "@vendia", "client");
    if (!import_fs.default.existsSync(installedClientPath)) {
      throw new Error(`Could not find @vendia/client at ${installedClientPath}`);
    }
  }
  const sdkString = await generateTypescript({
    graphQlSchema,
    schemaJson,
    schemaNamespace
  });
  const sdkPath = import_path.default.join(dotVendiaClientPath, "generated.ts");
  import_fs.default.writeFile(sdkPath, sdkString, () => {
    debug("Codegen files generated at:", sdkPath);
    debugInfo.codegenFilesGeneratedAt = sdkPath;
  });
  const installedClientSourcePath = import_path.default.join(installedClientPath, "src");
  copyFolderSync(installedClientSourcePath, dotVendiaClientPath);
  const typeDefFilePath = import_path.default.join(dotVendiaClientPath, "index.d.ts");
  if (import_fs.default.existsSync(typeDefFilePath)) {
    debug("Deleted previous index.d.ts file");
    import_fs.default.unlinkSync(typeDefFilePath);
  } else {
    debug("No previous index.d.ts file to delete");
  }
  const indexFilePath = import_path.default.join(dotVendiaClientPath, "index.ts").replace(/\\/g, "/");
  console.log("Compiling TypeScript to js/d.ts files...");
  const tsconfigPath = import_path.default.join(installedClientPath, "tsconfig.json");
  await compileTs(indexFilePath, version, {
    outDir: dotVendiaClientPath,
    tsconfig: tsconfigPath,
    dts: {
      entry: [
        indexFilePath,
        import_path.default.join(dotVendiaClientPath, "generated.ts").replace(/\\/g, "/"),
        import_path.default.join(dotVendiaClientPath, "types.ts").replace(/\\/g, "/")
      ]
    }
  });
  const tsconfigModulePath = import_path.default.join(installedClientPath, "tsconfig.module.json");
  await compileTs(indexFilePath, version, {
    outDir: dotVendiaClientPath,
    tsconfig: tsconfigModulePath,
    format: ["esm"]
  });
  debugInfo.secondsWaitingForDtsFileGeneration = 0;
  for (let i = 0; i < 20; i++) {
    if (import_fs.default.existsSync(typeDefFilePath)) {
      await delay(500);
      import_fs.default.readdirSync(dotVendiaClientPath, { withFileTypes: true }).filter((f) => f.isFile() && !f.name.endsWith(".d.ts") && !f.name.endsWith(".js")).map((f) => {
        debug("Deleting copied TypeScript source file:", f.name);
        import_fs.default.unlinkSync(import_path.default.join(dotVendiaClientPath, f.name));
      });
      break;
    } else {
      await delay(1e3);
      debugInfo.secondsWaitingForDtsFileGeneration = i;
    }
  }
  if (debugInfo.secondsWaitingForDtsFileGeneration >= 19) {
    console.log("Waited 20 seconds for d.ts file generation in order to delete copied TypeScript source files, but did not find index.d.ts file. Moving on.");
  }
  console.log("Vendia client generated successfully!");
};
var delay = (ms) => new Promise((res) => setTimeout(res, ms));
function copyFolderSync(from, to) {
  if (!import_fs.default.existsSync(to)) {
    import_fs.default.mkdirSync(to);
  }
  import_fs.default.readdirSync(from).forEach((element) => {
    if (import_fs.default.lstatSync(import_path.default.join(from, element)).isFile()) {
      import_fs.default.copyFileSync(import_path.default.join(from, element), import_path.default.join(to, element));
    } else {
      copyFolderSync(import_path.default.join(from, element), import_path.default.join(to, element));
    }
  });
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  compileTs,
  generateClient,
  generateTypescript
});
