var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { codegen } from '@graphql-codegen/core';
import { operations } from './commonOperations';
import { generateEntityOperations } from './entityOperations';
import { printSchema, parse } from 'graphql';
import $RefParser from '@apidevtools/json-schema-ref-parser';
export const generateTypescript = function ({ graphQlSchema, schemaJson, schemaNamespace }) {
    return __awaiter(this, void 0, void 0, function* () {
        const dereferencedSchema = yield $RefParser.dereference(schemaJson, { dereference: { circular: false } });
        // Use that to generate the entity operations
        const entityOperations = generateEntityOperations(dereferencedSchema, schemaNamespace);
        // Grab some common operations & merge with entity operations
        const allOperations = operations + entityOperations;
        const plugins = [
            {
                typescript: {
                    // This prevents code that requires enum values from requiring the actual enum
                    // eg, for syncMode, we can just pass the string 'ASYNC' rather than needing to import
                    // and use Vendia_SyncMode.Async. Also, even if we wanted to use the enum, I had problems
                    // trying to use import it from the generated d.ts file and use it as a runtime value
                    enumsAsTypes: true,
                },
            },
            {
                typescriptOperations: {
                    // This is supposed to be the default, but I'm not seeing this behavior in the generated code...
                    arrayInputCoercion: true,
                },
            },
            {
                vendiaClientPlugin: {
                    schemaNamespace,
                    schemaJson: dereferencedSchema,
                },
            },
        ];
        const config = {
            documents: [{ document: parse(allOperations) }],
            config: {
                namingConvention: 'keep',
            },
            // used by a plugin internally, although the 'typescript' plugin currently
            // returns the string output, rather than writing to a file
            filename: 'generated.ts',
            schema: parse(printSchema(graphQlSchema)),
            plugins,
            pluginMap: {
                // Loading these packages on-demand (as the official demo site for graphQL codegen does) seems to bypass
                // some strange module loading issues that occur otherwise (process.hrtime is not a function)
                typescript: yield import('@graphql-codegen/typescript'),
                typescriptOperations: yield import('@graphql-codegen/typescript-operations'),
                vendiaClientPlugin: yield import('@vendia/codegen-vendia-client-plugin'),
            },
        };
        return codegen(config);
    });
};
