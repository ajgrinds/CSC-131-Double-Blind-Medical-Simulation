{"version":3,"sources":["../../src/index.ts","../../src/visitor.ts","../../../../../node_modules/.pnpm/auto-bind@5.0.1/node_modules/auto-bind/index.js"],"sourcesContent":["import { Types, PluginValidateFn, PluginFunction, oldVisit } from '@graphql-codegen/plugin-helpers'\nimport { GraphQLSchema, concatAST, Kind, FragmentDefinitionNode } from 'graphql'\nimport { RawClientSideBasePluginConfig, LoadedFragment } from '@graphql-codegen/visitor-plugin-common'\nimport { GraphQLRequestVisitor } from './visitor'\nimport { extname } from 'path'\nimport { RawGraphQLRequestPluginConfig } from './config'\n\nexport const plugin: PluginFunction<RawGraphQLRequestPluginConfig> = (\n  schema: GraphQLSchema,\n  documents: Types.DocumentFile[],\n  config: RawGraphQLRequestPluginConfig,\n) => {\n  // @ts-ignore - document doesn't exist on v? This code is from graphql-code-generator so let's ignore for now\n  const allAst = concatAST(documents.map((v) => v.document))\n  const allFragments: LoadedFragment[] = [\n    ...(allAst.definitions.filter((d) => d.kind === Kind.FRAGMENT_DEFINITION) as FragmentDefinitionNode[]).map(\n      (fragmentDef) => ({\n        node: fragmentDef,\n        name: fragmentDef.name.value,\n        onType: fragmentDef.typeCondition.name.value,\n        isExternal: false,\n      }),\n    ),\n    ...(config.externalFragments || []),\n  ]\n  const visitor = new GraphQLRequestVisitor(schema, allFragments, config)\n  const visitorResult = oldVisit(allAst, { leave: visitor })\n\n  return {\n    prepend: visitor.getImports(),\n    content: [\n      visitor.fragments,\n      ...visitorResult.definitions.filter((t) => typeof t === 'string'),\n      visitor.sdkContent,\n    ].join('\\n'),\n  }\n}\n\nexport const validate: PluginValidateFn<any> = async (\n  schema: GraphQLSchema,\n  documents: Types.DocumentFile[],\n  config: RawClientSideBasePluginConfig,\n  outputFile: string,\n) => {\n  if (extname(outputFile) !== '.ts') {\n    throw new Error(`Plugin \"typescript-graphql-request\" requires extension to be \".ts\"!`)\n  }\n}\n\nexport { GraphQLRequestVisitor }\n","import {\n  ClientSideBasePluginConfig,\n  ClientSideBaseVisitor,\n  DocumentMode,\n  getConfigValue,\n  indentMultiline,\n  LoadedFragment,\n} from '@graphql-codegen/visitor-plugin-common'\nimport autoBind from 'auto-bind'\nimport camelCase from 'camelcase'\nimport { GraphQLSchema, /*Kind,*/ OperationDefinitionNode, print } from 'graphql'\nimport { RawGraphQLRequestPluginConfig } from './config'\n\nexport interface GraphQLRequestPluginConfig extends ClientSideBasePluginConfig {\n  rawRequest: boolean\n  extensionsType: string\n  schemaNamespace: string\n  schemaJson: Record<string, unknown>\n}\n\ninterface Operation {\n  node: OperationDefinitionNode\n  documentVariableName: string\n  operationType: string\n  operationResultType: string\n  operationVariablesTypes: string\n}\n\n// Underscores aren't allowed in entity names so we're safe to use\n//  this simple separator in our generated query names.\n// Pattern is <entity>__<operation>, eg query Product__get { ... }\nconst queryNameSeparator = '__'\n\nconst vendiaNamespaceToTypeMap = {\n  blocks: 'Block',\n  files: 'File',\n  folders: 'Folder',\n  contracts: 'Contract',\n  settings: 'Settings',\n  deployments: 'DeploymentInfo',\n  uniInfo: 'UniInfo',\n}\n\nconst additionalExportedTypes = `\nexport type SdkFunctionWrapper = <T>(action: (requestHeaders?:Record<string, string>) => Promise<T>, operationName: string) => Promise<T>;\n`\nconst additionalTypeHelpers = `\n// Return value of subscriptions\nexport type Unsubscribe = () => void;\n`\n\nexport class GraphQLRequestVisitor extends ClientSideBaseVisitor<\n  RawGraphQLRequestPluginConfig,\n  GraphQLRequestPluginConfig\n> {\n  private _operationsToInclude: Operation[] = []\n\n  constructor(schema: GraphQLSchema, fragments: LoadedFragment[], rawConfig: RawGraphQLRequestPluginConfig) {\n    super(schema, fragments, rawConfig, {\n      rawRequest: getConfigValue(rawConfig.rawRequest, false),\n      extensionsType: getConfigValue(rawConfig.extensionsType, 'any'),\n      schemaNamespace: getConfigValue(rawConfig.schemaNamespace, 'Self'),\n      schemaJson: getConfigValue(rawConfig.schemaJson, {}),\n    })\n\n    autoBind(this)\n\n    const typeImport = this.config.useTypeImports ? 'import type' : 'import'\n\n    this._additionalImports.push(`${typeImport} { GraphQLClient } from 'graphql-request';`)\n    this._additionalImports.push(`${typeImport} * as Dom from 'graphql-request/dist/types.dom';`)\n\n    // if (this.config.rawRequest) {\n    //   this._additionalImports.push(`${typeImport} { GraphQLError } from 'graphql-request/dist/types';`);\n    //   if (this.config.documentMode !== DocumentMode.string) {\n    //     this._additionalImports.push(`import { print } from 'graphql'`);\n    //   }\n    // }\n  }\n\n  public OperationDefinition(node: OperationDefinitionNode) {\n    const operationName = node.name?.value\n\n    if (!operationName) {\n      // eslint-disable-next-line no-console\n      console.warn(\n        `Anonymous GraphQL operation was ignored in \"typescript-graphql-request\", please make sure to name your operation: `,\n        print(node),\n      )\n\n      return null\n    }\n\n    return super.OperationDefinition(node)\n  }\n\n  // You can build up operations with this method and return a string, but each operation will be processed independently\n  // Here we push all the operations together so we can build an SDK object in sdkContent method below\n  protected buildOperation(\n    node: OperationDefinitionNode,\n    documentVariableName: string,\n    operationType: string,\n    operationResultType: string,\n    operationVariablesTypes: string,\n  ): string {\n    this._operationsToInclude.push({\n      node,\n      documentVariableName,\n      operationType,\n      operationResultType,\n      operationVariablesTypes,\n    })\n\n    return null\n  }\n\n  private getDocumentNodeVariable(documentVariableName: string): string {\n    return this.config.documentMode === DocumentMode.external\n      ? `Operations.${documentVariableName}`\n      : documentVariableName\n  }\n\n  public get sdkContent(): string {\n    console.log('Generating TypeScript code...')\n    const extraVariables: string[] = []\n    const extraTypes: string[] = []\n\n    const groupedOperationsByEntity: { [key: string]: Operation[] } = {}\n    const groupedVendiaOperations: { [key: string]: Operation[] } = {}\n\n    this._operationsToInclude.forEach((o) => {\n      const operationGroup = o.node.name.value.split(queryNameSeparator)[0]\n      if (operationGroup.startsWith('_')) {\n        const vendiaGroup = operationGroup.slice(1)\n        if (!groupedVendiaOperations[vendiaGroup]) {\n          groupedVendiaOperations[vendiaGroup] = [o]\n        } else {\n          groupedVendiaOperations[vendiaGroup].push(o)\n        }\n      } else {\n        if (!groupedOperationsByEntity[operationGroup]) {\n          groupedOperationsByEntity[operationGroup] = [o]\n        } else {\n          groupedOperationsByEntity[operationGroup].push(o)\n        }\n      }\n    })\n\n    const groupedVendiaActions: any = {}\n    Object.entries(groupedVendiaOperations).forEach(([vendiaNamespace, vendiaOperations]) => {\n      const vendiaActions = vendiaOperations.map(buildAction.bind(this)).map((s) => indentMultiline(s as string, 2))\n      groupedVendiaActions[vendiaNamespace] = vendiaActions.join(',\\n')\n    })\n\n    const groupedActionsByEntity = Object.entries(groupedOperationsByEntity)\n      .map(([entity, operations]) => {\n        const actions = operations\n          .map(buildAction.bind(this))\n          .filter(Boolean)\n          .map((s) => indentMultiline(s as string, 1))\n        const camelCaseEntity = camelCase(entity, { preserveConsecutiveUppercase: true, locale: false })\n        return `${camelCaseEntity}: {\\n${actions.join(',\\n')}\\n}`\n      })\n      .map((s) => indentMultiline(s as string, 2))\n\n    return `\n${additionalExportedTypes}\n${additionalTypeHelpers}\n${extraVariables.join('\\n')}\n${extraTypes.join('\\n')}\n\nconst defaultWrapper: SdkFunctionWrapper = (action, _operationName) => action();\n\ninterface GetSdkNamespaceOptions {\n  _gqlClient: GraphQLClient;\n  _requestWrapper: SdkFunctionWrapper;\n  _subscribe: any;\n}\n\n\nexport function getEntities({_gqlClient, _subscribe, _requestWrapper = defaultWrapper}: GetSdkNamespaceOptions) {\n  return {\n${groupedActionsByEntity.join(',\\n')}\n  };\n}\n\ntype GetEntities = ReturnType<typeof getEntities>\n\nexport function getBlocks({_gqlClient, _subscribe, _requestWrapper = defaultWrapper}: GetSdkNamespaceOptions) {\n  return {\n${groupedVendiaActions.blocks}\n  };\n}\n\ntype GetBlocks = ReturnType<typeof getBlocks>\n\nexport function getContracts({_gqlClient, _subscribe, _requestWrapper = defaultWrapper}: GetSdkNamespaceOptions) {\n  return {\n${groupedVendiaActions.contracts}\n  };\n}\n\ntype GetContracts = ReturnType<typeof getContracts>\n\nexport function getFiles({_gqlClient, _subscribe, _requestWrapper = defaultWrapper}: GetSdkNamespaceOptions) {\n  return {\n${groupedVendiaActions.files}\n  };\n}\n\ntype GetFiles = ReturnType<typeof getFiles>\n\nexport function getFolders({_gqlClient, _subscribe, _requestWrapper = defaultWrapper}: GetSdkNamespaceOptions) {\n  return {\n${groupedVendiaActions.folders}\n  };\n}\n\ntype GetFolders = ReturnType<typeof getFolders>\n\nexport function getDeployments({_gqlClient, _subscribe, _requestWrapper = defaultWrapper}: GetSdkNamespaceOptions) {\n  return {\n${groupedVendiaActions.deployments}\n  };\n}\n\ntype GetDeployments = ReturnType<typeof getDeployments>\n\nexport function getSettings({_gqlClient, _subscribe, _requestWrapper = defaultWrapper}: GetSdkNamespaceOptions) {\n  return {\n${groupedVendiaActions.settings}\n  };\n}\n\ntype GetSettings = ReturnType<typeof getSettings>\n\nexport function getUniInfo({_gqlClient, _subscribe, _requestWrapper = defaultWrapper}: GetSdkNamespaceOptions) {\n  return {\n${groupedVendiaActions.uniInfo}\n  };\n}\n\ntype GetUniInfo = ReturnType<typeof getUniInfo>\n\n\n// For fields returned in the __Partial__ section of ACL queries, we alias each field with \"__alias__\" to avoid\n// graphQL errors. Replace alias fields with their original field name (top-level fields only, not recursive)\nconst ALIAS_PREFIX = '__alias__';\n// Use generics to retain the type that was passed in\nfunction stripAliasPrefixesFromKeys<T>(value: any): T {\n  // Handle top-level scalars\n  if (typeof value === 'boolean' || typeof value === 'number' || typeof value === 'string' || value == null) {\n    return value;\n  }\n  \n  // Handles top-level arrays and top-level objects\n  if (Array.isArray(value)) {\n    return value.map((item) => stripAliasPrefixesFromKeys(item)) as unknown as T\n  }\n\n  const clean: any = {}\n  Object.entries(value).forEach(([key, val]) => {\n    if (key.startsWith(ALIAS_PREFIX)) {\n      clean[key.replace(ALIAS_PREFIX, '')] = val\n    } else {\n      clean[key] = val\n    }\n  })\n  return clean\n}\n`\n\n    // TODO - build all the response types and export them in the following format\n    // type GetEntities = ReturnType<typeof getEntities>\n    // export type ScalarGetResponse = GetEntities['scalar']['get']\n    // export type ScalarCreateResponse = GetEntities['scalar']['create']\n\n    function buildAction(this: GraphQLRequestVisitor, o: Operation): string {\n      // console.log('-----------------------------------');\n      // console.log('-----------------------------------');\n      // console.log(o.node);\n      // console.log('variable 1', o.node.variableDefinitions[0]?.variable.name.value);\n      // console.log('variable 1', o.node.variableDefinitions[0]?.variable);\n      // console.log('variable 2', o.node.variableDefinitions[1]?.variable.name.value);\n      // console.log('variable 3', o.node.variableDefinitions[2]?.variable.name.value);\n\n      // @ts-ignore - parses query name (eg, listVendia_FolderItems or list_ProductItems) to determine which are in-house Vendia APIs\n      // const isVendiaOperation = o.node.selectionSet.selections[0].name.value.split('_')[0].includes('Vendia')\n      // console.log(o.node.selectionSet.selections[0].name.value, isVendiaOperation);\n\n      // entityName will be 'product' for user entity, 'files' or 'blocks' for Vendia APIs\n      let entityName = o.node.name.value.split(queryNameSeparator)[0]\n      // _contracts, _blocks, etc\n      const isVendiaOperation = entityName.startsWith('_')\n      if (isVendiaOperation) {\n        // _contracts becomes contract, _uniInfo becomes uniInfo\n        entityName = entityName.slice(1)\n      }\n      const numVariables = o.node.variableDefinitions.length\n\n      let operationName = o.node.name.value\n      // Rename method to just \"list\" or \"add\", etc.\n      if (o.node.name.value.includes(queryNameSeparator)) {\n        operationName = o.node.name.value.split(queryNameSeparator)[1]\n      }\n\n      // Need to handle some special cases for this one-off API\n      const isInvokeContract = operationName === 'invoke' && entityName === 'contracts'\n\n      const entitiesWithAcl = Object.values(this.config.schemaJson?.['x-vendia-acls'] ?? {}).reduce((acc, { type }) => {\n        acc[type] = true\n        return acc\n      }, {})\n      // Special case for contracts, the only Vendia entity that has ACLs enabled\n      const isAclEnabled = entitiesWithAcl[entityName] || isInvokeContract\n\n      // graphql-request uses \"variables\" nomenclature, but we're elevating required/primary input to first arg and the rest become \"options\"\n      let parameters = `options?: ${o.operationVariablesTypes}`\n\n      // We have to build up variables from options, input, and possibly id parameters. In case we don't just use this.\n      let mergeParamsIntoVariables = `const variables = options`\n\n      // Have to build a new type for options minus whatever we're promoting to the first/second parameters for some operations\n      const optionsTypeName = `${entityName}${capitalizeFirstLetter(operationName)}OptionsParameter`\n\n      const hasInputVariable = o.node.variableDefinitions.find((v) => v?.variable?.name?.value === 'input')\n      const hasIdVariable = o.node.variableDefinitions.find((v) => v?.variable?.name?.value === 'id')\n\n      if (o.operationType === 'Query') {\n        // product.get(id, options) instead of product.get(options)\n        if (operationName === 'get' && hasIdVariable) {\n          extraTypes.push(`export type ${optionsTypeName} = Omit<${o.operationVariablesTypes}, 'id'>;`)\n          parameters = `id: string, options?: ${optionsTypeName}`\n          mergeParamsIntoVariables = `const variables = { ...options, id }`\n        }\n      }\n\n      if (o.operationType === 'Mutation') {\n        // Must be an add/create mutation\n        if (hasInputVariable && !hasIdVariable) {\n          if (numVariables === 1) {\n            // Don't include options param when there are ZERO additional options besides input\n            parameters = `input: ${o.operationVariablesTypes}['input']`\n            mergeParamsIntoVariables = `const variables = { input }`\n          } else {\n            // Build a new type for the rest of the options minus 'input'\n            extraTypes.push(`export type ${optionsTypeName} = Omit<${o.operationVariablesTypes}, 'input'>;`)\n            // There are additional options besides input, accept them and merge them into the variables\n            parameters = `input: ${o.operationVariablesTypes}['input'], options?: ${optionsTypeName}`\n            mergeParamsIntoVariables = `const variables = { ...options, input }`\n          }\n        }\n\n        // Must be a put/update mutation\n        if (hasInputVariable && hasIdVariable && !isInvokeContract) {\n          // Is input a scalar or object? If it's an object, we can pull _id out of it and pass that to id variable\n          // @ts-ignore - maybe this is a bug, but this is where the type is located in the AST and typescript doesn't think it should exist...\n          const isStringInput = hasInputVariable?.type?.type?.name?.value === 'String'\n\n          // Build a new type for the rest of the options minus 'id' and 'input'\n          extraTypes.push(`export type ${optionsTypeName} = Omit<${o.operationVariablesTypes}, 'id' | 'input'>;`)\n\n          if (isStringInput) {\n            // product.update(id: string, input: string, condition: )\n            parameters = `id: string, input: string, options?: ${optionsTypeName}`\n            mergeParamsIntoVariables = `const variables = { ...options, id, input }`\n          } else {\n            // Nicer API to mutate objects - just pass in the same object you'd receive from a get() and we split the id out for you\n            // product.update(input: { _id: string, name: string })\n            // Build a new type which includes _id\n            const inputTypeName = `${entityName}${capitalizeFirstLetter(operationName)}InputParameter`\n            extraTypes.push(`export type ${inputTypeName} = ${o.operationVariablesTypes}['input'] & { _id: string };`)\n            // Extract _id from the new input type and pass it to the id variable\n            parameters = `input: ${inputTypeName}, options?: ${optionsTypeName}`\n            mergeParamsIntoVariables = `const { _id, ...rest } = input;\\n  const variables = { ...options, id: _id, input: rest }`\n          }\n        }\n\n        // Must be a delete mutation (or invoke contract!)\n        if ((hasIdVariable && !hasInputVariable) || isInvokeContract) {\n          // product.delete(id: string)\n          // Build a new type for the rest of the options minus 'id'\n          extraTypes.push(`export type ${optionsTypeName} = Omit<${o.operationVariablesTypes}, 'id'>;`)\n          parameters = `id: string, options?: ${optionsTypeName}`\n          mergeParamsIntoVariables = `const variables = { ...options, id }`\n        }\n      }\n\n      // Note: improve response ergonomics!\n      // We don't support batch queries, so we can simplify query responses - don't\n      // include the outer query wrapper (eg, list__ProductItems)\n      let queryNameSuffix = ''\n      let queryOperationName = operationName\n      if (operationName === 'list') {\n        queryNameSuffix = 'Items'\n      } else if (operationName.includes('Versions')) {\n        queryNameSuffix = 'Versions'\n        queryOperationName = operationName.replace('Versions', '')\n      }\n\n      let queryName = `${queryOperationName}_${entityName}${queryNameSuffix}`\n      if (isVendiaOperation) {\n        // 'blocks' becomes 'Block'\n        const vendiaType = vendiaNamespaceToTypeMap[entityName]\n        queryName = `${queryOperationName}Vendia_${vendiaType}${queryNameSuffix}`\n      }\n\n      // Extract the value located at the query name in response\n      let returnValueChain = `\\n      .then(res => res.${queryName})`\n      let resultType = `${o.operationResultType}['${queryName}']`\n\n      // Doing some extra work for list operations - replacing the _EntityItems field\n      // with a consistent \"items\" field to make responses easier and more predictable\n      if (operationName === 'list') {\n        // Cut \"list\" off of \"list_ProductItems\" or \"listVendia_FileItems\"\n        const verboseResponseField = queryName.slice(4)\n        returnValueChain = `\\n      .then(res => { const updatedRes = { ...res.${queryName}, items: res.${queryName}?.${verboseResponseField}}; delete updatedRes.${verboseResponseField}; return updatedRes })`\n        resultType = `ReplaceVerboseFieldWithItems<${resultType}>`\n      }\n\n      // ----- Help users with ACLs -----\n      // Doing some extra work for get/list operations that might have ACLs enabled - strip the aliases off for the user!\n      // More context: for fields returned in the __Partial__ section of ACL queries, we alias each field with \"__alias__\" to avoid\n      // graphQL errors. Replace alias fields with their original field name (top-level fields only, not recursive)\n      const operationsWithAliasedFieldResults = ['get', 'list', 'add', 'create', 'update']\n      if (isAclEnabled && operationsWithAliasedFieldResults.includes(operationName)) {\n        let partialTypeName = `${this.config.schemaNamespace}_${entityName}_Partial_`\n        if (entityName === 'contracts') {\n          partialTypeName = 'Vendia_Contract_Partial_'\n        }\n        // Note the += operator, we're chaining another .then()\n        if (operationName === 'get') {\n          returnValueChain += `\\n      .then(res => {\n          return stripAliasPrefixesFromKeys<${partialTypeName}>(res);\n      })`\n        } else if (operationName === 'list') {\n          returnValueChain += `\\n      .then(res => {\n          const items = stripAliasPrefixesFromKeys<${partialTypeName}[]>(res.items);\n          return { ...res, items };\n      })`\n        } else {\n          // The mutations all follow same pattern with aliased fields in result\n          // Note: ${partialTypeName} | undefined is quick way to tell typescript that result won't be there for ASYNC mutations\n          returnValueChain += `\\n      .then(res => {\n          const result = stripAliasPrefixesFromKeys<${partialTypeName} | undefined>(res?.result);\n          return { ...res, result };\n      })`\n        }\n      }\n\n      // Return line for queries and mutations\n      const docVarName = this.getDocumentNodeVariable(o.documentVariableName)\n      const returnLine = `return _requestWrapper((wrappedRequestHeaders) => { \n    return _gqlClient.request<${o.operationResultType}>(${docVarName}, variables, wrappedRequestHeaders)${returnValueChain}; \n  }, '${queryName}');`\n\n      // ----- Subscriptions! -----\n      // TODO - add support for stripping ACL aliases when we fix subscriptions ACL bug\n      if (o.operationType === 'Subscription') {\n        return `${operationName}(handler: (value: ${resultType}) => void): Unsubscribe {\n  return _subscribe({query: ${docVarName}}, ({ data }: any) =>  { return handler(data.${queryName}) })\n}`\n      }\n\n      // May never need rawRequest so focusing on basic request for now, can refactor to add this back later if needed\n      //       if (this.config.rawRequest) {\n      //         let docArg = docVarName;\n      //         if (this.config.documentMode !== DocumentMode.string) {\n      //           docArg = `${docVarName}String`;\n      //           extraVariables.push(`const ${docArg} = print(${docVarName});`);\n      //         }\n      //         return `${operationName}(variables${variablesAreOptional ? '?' : ''}: ${\n      //           o.operationVariablesTypes\n      //         }, requestHeaders?: Dom.RequestInit[\"headers\"]): Promise<{ data?: ${\n      //           o.operationResultType\n      //         } | undefined; extensions?: ${\n      //           this.config.extensionsType\n      //         }; headers: Dom.Headers; status: number; errors?: GraphQLError[] | undefined; }> {\n      //     return _requestWrapper((wrappedRequestHeaders) => _gqlClient.rawRequest<${\n      //           o.operationResultType\n      //         }>(${docArg}, variables, {...requestHeaders, ...wrappedRequestHeaders}), '${operationName}');\n      // }`;\n      //       } else {\n\n      // If there are zero variables, don't ask users for an options object\n      // Top-level scalar get(), uniInfo.get()\n      if (numVariables === 0) {\n        parameters = ''\n        mergeParamsIntoVariables = `const variables = {}`\n      }\n\n      // TODO - seems like I can clean up a lot of my code trying to come up with accurate types for the return value of the operation\n      //  Typescript is smart enough to figure it out by inferring from the code I'm adding - if this works, remove all resultType stuff above\n      //  return `${operationName}(${parameters}): Promise<${resultType}> {\n      return `${operationName}(${parameters}) {\n  ${mergeParamsIntoVariables}\n  ${returnLine}\n}`\n    }\n  }\n}\n\nfunction capitalizeFirstLetter(string) {\n  return string[0].toUpperCase() + string.slice(1)\n}\n","// Gets all non-builtin properties up the prototype chain.\nconst getAllProperties = object => {\n\tconst properties = new Set();\n\n\tdo {\n\t\tfor (const key of Reflect.ownKeys(object)) {\n\t\t\tproperties.add([object, key]);\n\t\t}\n\t} while ((object = Reflect.getPrototypeOf(object)) && object !== Object.prototype);\n\n\treturn properties;\n};\n\nexport default function autoBind(self, {include, exclude} = {}) {\n\tconst filter = key => {\n\t\tconst match = pattern => typeof pattern === 'string' ? key === pattern : pattern.test(key);\n\n\t\tif (include) {\n\t\t\treturn include.some(match); // eslint-disable-line unicorn/no-array-callback-reference\n\t\t}\n\n\t\tif (exclude) {\n\t\t\treturn !exclude.some(match); // eslint-disable-line unicorn/no-array-callback-reference\n\t\t}\n\n\t\treturn true;\n\t};\n\n\tfor (const [object, key] of getAllProperties(self.constructor.prototype)) {\n\t\tif (key === 'constructor' || !filter(key)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst descriptor = Reflect.getOwnPropertyDescriptor(object, key);\n\t\tif (descriptor && typeof descriptor.value === 'function') {\n\t\t\tself[key] = self[key].bind(self);\n\t\t}\n\t}\n\n\treturn self;\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,4BAAkE;AAClE,IAAAA,kBAAuE;;;ACDvE,mCAOO;;;ACNP,IAAM,mBAAmB,YAAU;AAClC,QAAM,aAAa,oBAAI,IAAI;AAE3B,KAAG;AACF,eAAW,OAAO,QAAQ,QAAQ,MAAM,GAAG;AAC1C,iBAAW,IAAI,CAAC,QAAQ,GAAG,CAAC;AAAA,IAC7B;AAAA,EACD,UAAU,SAAS,QAAQ,eAAe,MAAM,MAAM,WAAW,OAAO;AAExE,SAAO;AACR;AAEe,SAAR,SAA0B,MAAM,EAAC,SAAS,QAAO,IAAI,CAAC,GAAG;AAC/D,QAAM,SAAS,SAAO;AACrB,UAAM,QAAQ,aAAW,OAAO,YAAY,WAAW,QAAQ,UAAU,QAAQ,KAAK,GAAG;AAEzF,QAAI,SAAS;AACZ,aAAO,QAAQ,KAAK,KAAK;AAAA,IAC1B;AAEA,QAAI,SAAS;AACZ,aAAO,CAAC,QAAQ,KAAK,KAAK;AAAA,IAC3B;AAEA,WAAO;AAAA,EACR;AAEA,aAAW,CAAC,QAAQ,GAAG,KAAK,iBAAiB,KAAK,YAAY,SAAS,GAAG;AACzE,QAAI,QAAQ,iBAAiB,CAAC,OAAO,GAAG,GAAG;AAC1C;AAAA,IACD;AAEA,UAAM,aAAa,QAAQ,yBAAyB,QAAQ,GAAG;AAC/D,QAAI,cAAc,OAAO,WAAW,UAAU,YAAY;AACzD,WAAK,OAAO,KAAK,KAAK,KAAK,IAAI;AAAA,IAChC;AAAA,EACD;AAEA,SAAO;AACR;;;AD/BA,uBAAsB;AACtB,qBAAwE;AAqBxE,IAAM,qBAAqB;AAE3B,IAAM,2BAA2B;AAAA,EAC/B,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,SAAS;AAAA,EACT,WAAW;AAAA,EACX,UAAU;AAAA,EACV,aAAa;AAAA,EACb,SAAS;AACX;AAEA,IAAM,0BAA0B;AAAA;AAAA;AAGhC,IAAM,wBAAwB;AAAA;AAAA;AAAA;AAKvB,IAAM,wBAAN,cAAoC,mDAGzC;AAAA,EAGA,YAAY,QAAuB,WAA6B,WAA0C;AACxG,UAAM,QAAQ,WAAW,WAAW;AAAA,MAClC,gBAAY,6CAAe,UAAU,YAAY,KAAK;AAAA,MACtD,oBAAgB,6CAAe,UAAU,gBAAgB,KAAK;AAAA,MAC9D,qBAAiB,6CAAe,UAAU,iBAAiB,MAAM;AAAA,MACjE,gBAAY,6CAAe,UAAU,YAAY,CAAC,CAAC;AAAA,IACrD,CAAC;AARH,SAAQ,uBAAoC,CAAC;AAU3C,aAAS,IAAI;AAEb,UAAM,aAAa,KAAK,OAAO,iBAAiB,gBAAgB;AAEhE,SAAK,mBAAmB,KAAK,GAAG,sDAAsD;AACtF,SAAK,mBAAmB,KAAK,GAAG,4DAA4D;AAAA,EAQ9F;AAAA,EAEO,oBAAoB,MAA+B;AAhF5D;AAiFI,UAAM,iBAAgB,UAAK,SAAL,mBAAW;AAEjC,QAAI,CAAC,eAAe;AAElB,cAAQ;AAAA,QACN;AAAA,YACA,sBAAM,IAAI;AAAA,MACZ;AAEA,aAAO;AAAA,IACT;AAEA,WAAO,MAAM,oBAAoB,IAAI;AAAA,EACvC;AAAA,EAIU,eACR,MACA,sBACA,eACA,qBACA,yBACQ;AACR,SAAK,qBAAqB,KAAK;AAAA,MAC7B;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF,CAAC;AAED,WAAO;AAAA,EACT;AAAA,EAEQ,wBAAwB,sBAAsC;AACpE,WAAO,KAAK,OAAO,iBAAiB,0CAAa,WAC7C,cAAc,yBACd;AAAA,EACN;AAAA,EAEA,IAAW,aAAqB;AAC9B,YAAQ,IAAI,+BAA+B;AAC3C,UAAM,iBAA2B,CAAC;AAClC,UAAM,aAAuB,CAAC;AAE9B,UAAM,4BAA4D,CAAC;AACnE,UAAM,0BAA0D,CAAC;AAEjE,SAAK,qBAAqB,QAAQ,CAAC,MAAM;AACvC,YAAM,iBAAiB,EAAE,KAAK,KAAK,MAAM,MAAM,kBAAkB,EAAE;AACnE,UAAI,eAAe,WAAW,GAAG,GAAG;AAClC,cAAM,cAAc,eAAe,MAAM,CAAC;AAC1C,YAAI,CAAC,wBAAwB,cAAc;AACzC,kCAAwB,eAAe,CAAC,CAAC;AAAA,QAC3C,OAAO;AACL,kCAAwB,aAAa,KAAK,CAAC;AAAA,QAC7C;AAAA,MACF,OAAO;AACL,YAAI,CAAC,0BAA0B,iBAAiB;AAC9C,oCAA0B,kBAAkB,CAAC,CAAC;AAAA,QAChD,OAAO;AACL,oCAA0B,gBAAgB,KAAK,CAAC;AAAA,QAClD;AAAA,MACF;AAAA,IACF,CAAC;AAED,UAAM,uBAA4B,CAAC;AACnC,WAAO,QAAQ,uBAAuB,EAAE,QAAQ,CAAC,CAAC,iBAAiB,gBAAgB,MAAM;AACvF,YAAM,gBAAgB,iBAAiB,IAAI,YAAY,KAAK,IAAI,CAAC,EAAE,IAAI,CAAC,UAAM,8CAAgB,GAAa,CAAC,CAAC;AAC7G,2BAAqB,mBAAmB,cAAc,KAAK,KAAK;AAAA,IAClE,CAAC;AAED,UAAM,yBAAyB,OAAO,QAAQ,yBAAyB,EACpE,IAAI,CAAC,CAAC,QAAQ,UAAU,MAAM;AAC7B,YAAM,UAAU,WACb,IAAI,YAAY,KAAK,IAAI,CAAC,EAC1B,OAAO,OAAO,EACd,IAAI,CAAC,UAAM,8CAAgB,GAAa,CAAC,CAAC;AAC7C,YAAM,sBAAkB,iBAAAC,SAAU,QAAQ,EAAE,8BAA8B,MAAM,QAAQ,MAAM,CAAC;AAC/F,aAAO,GAAG;AAAA,EAAuB,QAAQ,KAAK,KAAK;AAAA;AAAA,IACrD,CAAC,EACA,IAAI,CAAC,UAAM,8CAAgB,GAAa,CAAC,CAAC;AAE7C,WAAO;AAAA,EACT;AAAA,EACA;AAAA,EACA,eAAe,KAAK,IAAI;AAAA,EACxB,WAAW,KAAK,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAapB,uBAAuB,KAAK,KAAK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQjC,qBAAqB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQrB,qBAAqB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQrB,qBAAqB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQrB,qBAAqB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQrB,qBAAqB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQrB,qBAAqB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQrB,qBAAqB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAuCnB,aAAS,YAAyC,GAAsB;AArR5E;AAmSM,UAAI,aAAa,EAAE,KAAK,KAAK,MAAM,MAAM,kBAAkB,EAAE;AAE7D,YAAM,oBAAoB,WAAW,WAAW,GAAG;AACnD,UAAI,mBAAmB;AAErB,qBAAa,WAAW,MAAM,CAAC;AAAA,MACjC;AACA,YAAM,eAAe,EAAE,KAAK,oBAAoB;AAEhD,UAAI,gBAAgB,EAAE,KAAK,KAAK;AAEhC,UAAI,EAAE,KAAK,KAAK,MAAM,SAAS,kBAAkB,GAAG;AAClD,wBAAgB,EAAE,KAAK,KAAK,MAAM,MAAM,kBAAkB,EAAE;AAAA,MAC9D;AAGA,YAAM,mBAAmB,kBAAkB,YAAY,eAAe;AAEtE,YAAM,kBAAkB,OAAO,QAAO,gBAAK,OAAO,eAAZ,mBAAyB,qBAAzB,YAA6C,CAAC,CAAC,EAAE,OAAO,CAAC,KAAK,EAAE,KAAK,MAAM;AAC/G,YAAI,QAAQ;AACZ,eAAO;AAAA,MACT,GAAG,CAAC,CAAC;AAEL,YAAM,eAAe,gBAAgB,eAAe;AAGpD,UAAI,aAAa,aAAa,EAAE;AAGhC,UAAI,2BAA2B;AAG/B,YAAM,kBAAkB,GAAG,aAAa,sBAAsB,aAAa;AAE3E,YAAM,mBAAmB,EAAE,KAAK,oBAAoB,KAAK,CAAC,MAAG;AArUnE,YAAAC,KAAAC;AAqUsE,iBAAAA,OAAAD,MAAA,uBAAG,aAAH,gBAAAA,IAAa,SAAb,gBAAAC,IAAmB,WAAU;AAAA,OAAO;AACpG,YAAM,gBAAgB,EAAE,KAAK,oBAAoB,KAAK,CAAC,MAAG;AAtUhE,YAAAD,KAAAC;AAsUmE,iBAAAA,OAAAD,MAAA,uBAAG,aAAH,gBAAAA,IAAa,SAAb,gBAAAC,IAAmB,WAAU;AAAA,OAAI;AAE9F,UAAI,EAAE,kBAAkB,SAAS;AAE/B,YAAI,kBAAkB,SAAS,eAAe;AAC5C,qBAAW,KAAK,eAAe,0BAA0B,EAAE,iCAAiC;AAC5F,uBAAa,yBAAyB;AACtC,qCAA2B;AAAA,QAC7B;AAAA,MACF;AAEA,UAAI,EAAE,kBAAkB,YAAY;AAElC,YAAI,oBAAoB,CAAC,eAAe;AACtC,cAAI,iBAAiB,GAAG;AAEtB,yBAAa,UAAU,EAAE;AACzB,uCAA2B;AAAA,UAC7B,OAAO;AAEL,uBAAW,KAAK,eAAe,0BAA0B,EAAE,oCAAoC;AAE/F,yBAAa,UAAU,EAAE,+CAA+C;AACxE,uCAA2B;AAAA,UAC7B;AAAA,QACF;AAGA,YAAI,oBAAoB,iBAAiB,CAAC,kBAAkB;AAG1D,gBAAM,kBAAgB,sEAAkB,SAAlB,mBAAwB,SAAxB,mBAA8B,SAA9B,mBAAoC,WAAU;AAGpE,qBAAW,KAAK,eAAe,0BAA0B,EAAE,2CAA2C;AAEtG,cAAI,eAAe;AAEjB,yBAAa,wCAAwC;AACrD,uCAA2B;AAAA,UAC7B,OAAO;AAIL,kBAAM,gBAAgB,GAAG,aAAa,sBAAsB,aAAa;AACzE,uBAAW,KAAK,eAAe,mBAAmB,EAAE,qDAAqD;AAEzG,yBAAa,UAAU,4BAA4B;AACnD,uCAA2B;AAAA;AAAA,UAC7B;AAAA,QACF;AAGA,YAAK,iBAAiB,CAAC,oBAAqB,kBAAkB;AAG5D,qBAAW,KAAK,eAAe,0BAA0B,EAAE,iCAAiC;AAC5F,uBAAa,yBAAyB;AACtC,qCAA2B;AAAA,QAC7B;AAAA,MACF;AAKA,UAAI,kBAAkB;AACtB,UAAI,qBAAqB;AACzB,UAAI,kBAAkB,QAAQ;AAC5B,0BAAkB;AAAA,MACpB,WAAW,cAAc,SAAS,UAAU,GAAG;AAC7C,0BAAkB;AAClB,6BAAqB,cAAc,QAAQ,YAAY,EAAE;AAAA,MAC3D;AAEA,UAAI,YAAY,GAAG,sBAAsB,aAAa;AACtD,UAAI,mBAAmB;AAErB,cAAM,aAAa,yBAAyB;AAC5C,oBAAY,GAAG,4BAA4B,aAAa;AAAA,MAC1D;AAGA,UAAI,mBAAmB;AAAA,yBAA4B;AACnD,UAAI,aAAa,GAAG,EAAE,wBAAwB;AAI9C,UAAI,kBAAkB,QAAQ;AAE5B,cAAM,uBAAuB,UAAU,MAAM,CAAC;AAC9C,2BAAmB;AAAA,mDAAsD,yBAAyB,cAAc,4CAA4C;AAC5J,qBAAa,gCAAgC;AAAA,MAC/C;AAMA,YAAM,oCAAoC,CAAC,OAAO,QAAQ,OAAO,UAAU,QAAQ;AACnF,UAAI,gBAAgB,kCAAkC,SAAS,aAAa,GAAG;AAC7E,YAAI,kBAAkB,GAAG,KAAK,OAAO,mBAAmB;AACxD,YAAI,eAAe,aAAa;AAC9B,4BAAkB;AAAA,QACpB;AAEA,YAAI,kBAAkB,OAAO;AAC3B,8BAAoB;AAAA;AAAA,8CACgB;AAAA;AAAA,QAEtC,WAAW,kBAAkB,QAAQ;AACnC,8BAAoB;AAAA;AAAA,qDACuB;AAAA;AAAA;AAAA,QAG7C,OAAO;AAGL,8BAAoB;AAAA;AAAA,sDACwB;AAAA;AAAA;AAAA,QAG9C;AAAA,MACF;AAGA,YAAM,aAAa,KAAK,wBAAwB,EAAE,oBAAoB;AACtE,YAAM,aAAa;AAAA,gCACO,EAAE,wBAAwB,gDAAgD;AAAA,QAClG;AAIF,UAAI,EAAE,kBAAkB,gBAAgB;AACtC,eAAO,GAAG,kCAAkC;AAAA,8BACtB,0DAA0D;AAAA;AAAA,MAElF;AAwBA,UAAI,iBAAiB,GAAG;AACtB,qBAAa;AACb,mCAA2B;AAAA,MAC7B;AAKA,aAAO,GAAG,iBAAiB;AAAA,IAC7B;AAAA,IACA;AAAA;AAAA,IAEA;AAAA,EACF;AACF;AAEA,SAAS,sBAAsB,QAAQ;AACrC,SAAO,OAAO,GAAG,YAAY,IAAI,OAAO,MAAM,CAAC;AACjD;;;ADpfA,kBAAwB;AAGjB,IAAM,SAAwD,CACnE,QACA,WACA,WACG;AAEH,QAAM,aAAS,2BAAU,UAAU,IAAI,CAAC,MAAM,EAAE,QAAQ,CAAC;AACzD,QAAM,eAAiC;AAAA,IACrC,GAAI,OAAO,YAAY,OAAO,CAAC,MAAM,EAAE,SAAS,qBAAK,mBAAmB,EAA+B;AAAA,MACrG,CAAC,iBAAiB;AAAA,QAChB,MAAM;AAAA,QACN,MAAM,YAAY,KAAK;AAAA,QACvB,QAAQ,YAAY,cAAc,KAAK;AAAA,QACvC,YAAY;AAAA,MACd;AAAA,IACF;AAAA,IACA,GAAI,OAAO,qBAAqB,CAAC;AAAA,EACnC;AACA,QAAM,UAAU,IAAI,sBAAsB,QAAQ,cAAc,MAAM;AACtE,QAAM,oBAAgB,gCAAS,QAAQ,EAAE,OAAO,QAAQ,CAAC;AAEzD,SAAO;AAAA,IACL,SAAS,QAAQ,WAAW;AAAA,IAC5B,SAAS;AAAA,MACP,QAAQ;AAAA,MACR,GAAG,cAAc,YAAY,OAAO,CAAC,MAAM,OAAO,MAAM,QAAQ;AAAA,MAChE,QAAQ;AAAA,IACV,EAAE,KAAK,IAAI;AAAA,EACb;AACF;AAEO,IAAM,WAAkC,CAC7C,QACA,WACA,QACA,eACG;AACH,UAAI,qBAAQ,UAAU,MAAM,OAAO;AACjC,UAAM,IAAI,MAAM,qEAAqE;AAAA,EACvF;AACF;","names":["import_graphql","camelCase","_a","_b"]}