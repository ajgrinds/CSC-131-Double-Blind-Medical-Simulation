"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  GraphQLRequestVisitor: () => GraphQLRequestVisitor,
  plugin: () => plugin,
  validate: () => validate
});
module.exports = __toCommonJS(src_exports);
var import_plugin_helpers = require("@graphql-codegen/plugin-helpers");
var import_graphql2 = require("graphql");

// src/visitor.ts
var import_visitor_plugin_common = require("@graphql-codegen/visitor-plugin-common");

// ../../../node_modules/.pnpm/auto-bind@5.0.1/node_modules/auto-bind/index.js
var getAllProperties = (object) => {
  const properties = /* @__PURE__ */ new Set();
  do {
    for (const key of Reflect.ownKeys(object)) {
      properties.add([object, key]);
    }
  } while ((object = Reflect.getPrototypeOf(object)) && object !== Object.prototype);
  return properties;
};
function autoBind(self, { include, exclude } = {}) {
  const filter = (key) => {
    const match = (pattern) => typeof pattern === "string" ? key === pattern : pattern.test(key);
    if (include) {
      return include.some(match);
    }
    if (exclude) {
      return !exclude.some(match);
    }
    return true;
  };
  for (const [object, key] of getAllProperties(self.constructor.prototype)) {
    if (key === "constructor" || !filter(key)) {
      continue;
    }
    const descriptor = Reflect.getOwnPropertyDescriptor(object, key);
    if (descriptor && typeof descriptor.value === "function") {
      self[key] = self[key].bind(self);
    }
  }
  return self;
}

// src/visitor.ts
var import_camelcase = __toESM(require("camelcase"));
var import_graphql = require("graphql");
var queryNameSeparator = "__";
var vendiaNamespaceToTypeMap = {
  blocks: "Block",
  files: "File",
  folders: "Folder",
  contracts: "Contract",
  settings: "Settings",
  deployments: "DeploymentInfo",
  uniInfo: "UniInfo"
};
var additionalExportedTypes = `
export type SdkFunctionWrapper = <T>(action: (requestHeaders?:Record<string, string>) => Promise<T>, operationName: string) => Promise<T>;
`;
var additionalTypeHelpers = `
// Return value of subscriptions
export type Unsubscribe = () => void;
`;
var GraphQLRequestVisitor = class extends import_visitor_plugin_common.ClientSideBaseVisitor {
  constructor(schema, fragments, rawConfig) {
    super(schema, fragments, rawConfig, {
      rawRequest: (0, import_visitor_plugin_common.getConfigValue)(rawConfig.rawRequest, false),
      extensionsType: (0, import_visitor_plugin_common.getConfigValue)(rawConfig.extensionsType, "any"),
      schemaNamespace: (0, import_visitor_plugin_common.getConfigValue)(rawConfig.schemaNamespace, "Self"),
      schemaJson: (0, import_visitor_plugin_common.getConfigValue)(rawConfig.schemaJson, {})
    });
    this._operationsToInclude = [];
    autoBind(this);
    const typeImport = this.config.useTypeImports ? "import type" : "import";
    this._additionalImports.push(`${typeImport} { GraphQLClient } from 'graphql-request';`);
    this._additionalImports.push(`${typeImport} * as Dom from 'graphql-request/dist/types.dom';`);
  }
  OperationDefinition(node) {
    var _a;
    const operationName = (_a = node.name) == null ? void 0 : _a.value;
    if (!operationName) {
      console.warn(
        `Anonymous GraphQL operation was ignored in "typescript-graphql-request", please make sure to name your operation: `,
        (0, import_graphql.print)(node)
      );
      return null;
    }
    return super.OperationDefinition(node);
  }
  buildOperation(node, documentVariableName, operationType, operationResultType, operationVariablesTypes) {
    this._operationsToInclude.push({
      node,
      documentVariableName,
      operationType,
      operationResultType,
      operationVariablesTypes
    });
    return null;
  }
  getDocumentNodeVariable(documentVariableName) {
    return this.config.documentMode === import_visitor_plugin_common.DocumentMode.external ? `Operations.${documentVariableName}` : documentVariableName;
  }
  get sdkContent() {
    console.log("Generating TypeScript code...");
    const extraVariables = [];
    const extraTypes = [];
    const groupedOperationsByEntity = {};
    const groupedVendiaOperations = {};
    this._operationsToInclude.forEach((o) => {
      const operationGroup = o.node.name.value.split(queryNameSeparator)[0];
      if (operationGroup.startsWith("_")) {
        const vendiaGroup = operationGroup.slice(1);
        if (!groupedVendiaOperations[vendiaGroup]) {
          groupedVendiaOperations[vendiaGroup] = [o];
        } else {
          groupedVendiaOperations[vendiaGroup].push(o);
        }
      } else {
        if (!groupedOperationsByEntity[operationGroup]) {
          groupedOperationsByEntity[operationGroup] = [o];
        } else {
          groupedOperationsByEntity[operationGroup].push(o);
        }
      }
    });
    const groupedVendiaActions = {};
    Object.entries(groupedVendiaOperations).forEach(([vendiaNamespace, vendiaOperations]) => {
      const vendiaActions = vendiaOperations.map(buildAction.bind(this)).map((s) => (0, import_visitor_plugin_common.indentMultiline)(s, 2));
      groupedVendiaActions[vendiaNamespace] = vendiaActions.join(",\n");
    });
    const groupedActionsByEntity = Object.entries(groupedOperationsByEntity).map(([entity, operations]) => {
      const actions = operations.map(buildAction.bind(this)).filter(Boolean).map((s) => (0, import_visitor_plugin_common.indentMultiline)(s, 1));
      const camelCaseEntity = (0, import_camelcase.default)(entity, { preserveConsecutiveUppercase: true, locale: false });
      return `${camelCaseEntity}: {
${actions.join(",\n")}
}`;
    }).map((s) => (0, import_visitor_plugin_common.indentMultiline)(s, 2));
    return `
${additionalExportedTypes}
${additionalTypeHelpers}
${extraVariables.join("\n")}
${extraTypes.join("\n")}

const defaultWrapper: SdkFunctionWrapper = (action, _operationName) => action();

interface GetSdkNamespaceOptions {
  _gqlClient: GraphQLClient;
  _requestWrapper: SdkFunctionWrapper;
  _subscribe: any;
}


export function getEntities({_gqlClient, _subscribe, _requestWrapper = defaultWrapper}: GetSdkNamespaceOptions) {
  return {
${groupedActionsByEntity.join(",\n")}
  };
}

type GetEntities = ReturnType<typeof getEntities>

export function getBlocks({_gqlClient, _subscribe, _requestWrapper = defaultWrapper}: GetSdkNamespaceOptions) {
  return {
${groupedVendiaActions.blocks}
  };
}

type GetBlocks = ReturnType<typeof getBlocks>

export function getContracts({_gqlClient, _subscribe, _requestWrapper = defaultWrapper}: GetSdkNamespaceOptions) {
  return {
${groupedVendiaActions.contracts}
  };
}

type GetContracts = ReturnType<typeof getContracts>

export function getFiles({_gqlClient, _subscribe, _requestWrapper = defaultWrapper}: GetSdkNamespaceOptions) {
  return {
${groupedVendiaActions.files}
  };
}

type GetFiles = ReturnType<typeof getFiles>

export function getFolders({_gqlClient, _subscribe, _requestWrapper = defaultWrapper}: GetSdkNamespaceOptions) {
  return {
${groupedVendiaActions.folders}
  };
}

type GetFolders = ReturnType<typeof getFolders>

export function getDeployments({_gqlClient, _subscribe, _requestWrapper = defaultWrapper}: GetSdkNamespaceOptions) {
  return {
${groupedVendiaActions.deployments}
  };
}

type GetDeployments = ReturnType<typeof getDeployments>

export function getSettings({_gqlClient, _subscribe, _requestWrapper = defaultWrapper}: GetSdkNamespaceOptions) {
  return {
${groupedVendiaActions.settings}
  };
}

type GetSettings = ReturnType<typeof getSettings>

export function getUniInfo({_gqlClient, _subscribe, _requestWrapper = defaultWrapper}: GetSdkNamespaceOptions) {
  return {
${groupedVendiaActions.uniInfo}
  };
}

type GetUniInfo = ReturnType<typeof getUniInfo>


// For fields returned in the __Partial__ section of ACL queries, we alias each field with "__alias__" to avoid
// graphQL errors. Replace alias fields with their original field name (top-level fields only, not recursive)
const ALIAS_PREFIX = '__alias__';
// Use generics to retain the type that was passed in
function stripAliasPrefixesFromKeys<T>(value: any): T {
  // Handle top-level scalars
  if (typeof value === 'boolean' || typeof value === 'number' || typeof value === 'string' || value == null) {
    return value;
  }
  
  // Handles top-level arrays and top-level objects
  if (Array.isArray(value)) {
    return value.map((item) => stripAliasPrefixesFromKeys(item)) as unknown as T
  }

  const clean: any = {}
  Object.entries(value).forEach(([key, val]) => {
    if (key.startsWith(ALIAS_PREFIX)) {
      clean[key.replace(ALIAS_PREFIX, '')] = val
    } else {
      clean[key] = val
    }
  })
  return clean
}
`;
    function buildAction(o) {
      var _a, _b, _c, _d, _e;
      let entityName = o.node.name.value.split(queryNameSeparator)[0];
      const isVendiaOperation = entityName.startsWith("_");
      if (isVendiaOperation) {
        entityName = entityName.slice(1);
      }
      const numVariables = o.node.variableDefinitions.length;
      let operationName = o.node.name.value;
      if (o.node.name.value.includes(queryNameSeparator)) {
        operationName = o.node.name.value.split(queryNameSeparator)[1];
      }
      const isInvokeContract = operationName === "invoke" && entityName === "contracts";
      const entitiesWithAcl = Object.values((_b = (_a = this.config.schemaJson) == null ? void 0 : _a["x-vendia-acls"]) != null ? _b : {}).reduce((acc, { type }) => {
        acc[type] = true;
        return acc;
      }, {});
      const isAclEnabled = entitiesWithAcl[entityName] || isInvokeContract;
      let parameters = `options?: ${o.operationVariablesTypes}`;
      let mergeParamsIntoVariables = `const variables = options`;
      const optionsTypeName = `${entityName}${capitalizeFirstLetter(operationName)}OptionsParameter`;
      const hasInputVariable = o.node.variableDefinitions.find((v) => {
        var _a2, _b2;
        return ((_b2 = (_a2 = v == null ? void 0 : v.variable) == null ? void 0 : _a2.name) == null ? void 0 : _b2.value) === "input";
      });
      const hasIdVariable = o.node.variableDefinitions.find((v) => {
        var _a2, _b2;
        return ((_b2 = (_a2 = v == null ? void 0 : v.variable) == null ? void 0 : _a2.name) == null ? void 0 : _b2.value) === "id";
      });
      if (o.operationType === "Query") {
        if (operationName === "get" && hasIdVariable) {
          extraTypes.push(`export type ${optionsTypeName} = Omit<${o.operationVariablesTypes}, 'id'>;`);
          parameters = `id: string, options?: ${optionsTypeName}`;
          mergeParamsIntoVariables = `const variables = { ...options, id }`;
        }
      }
      if (o.operationType === "Mutation") {
        if (hasInputVariable && !hasIdVariable) {
          if (numVariables === 1) {
            parameters = `input: ${o.operationVariablesTypes}['input']`;
            mergeParamsIntoVariables = `const variables = { input }`;
          } else {
            extraTypes.push(`export type ${optionsTypeName} = Omit<${o.operationVariablesTypes}, 'input'>;`);
            parameters = `input: ${o.operationVariablesTypes}['input'], options?: ${optionsTypeName}`;
            mergeParamsIntoVariables = `const variables = { ...options, input }`;
          }
        }
        if (hasInputVariable && hasIdVariable && !isInvokeContract) {
          const isStringInput = ((_e = (_d = (_c = hasInputVariable == null ? void 0 : hasInputVariable.type) == null ? void 0 : _c.type) == null ? void 0 : _d.name) == null ? void 0 : _e.value) === "String";
          extraTypes.push(`export type ${optionsTypeName} = Omit<${o.operationVariablesTypes}, 'id' | 'input'>;`);
          if (isStringInput) {
            parameters = `id: string, input: string, options?: ${optionsTypeName}`;
            mergeParamsIntoVariables = `const variables = { ...options, id, input }`;
          } else {
            const inputTypeName = `${entityName}${capitalizeFirstLetter(operationName)}InputParameter`;
            extraTypes.push(`export type ${inputTypeName} = ${o.operationVariablesTypes}['input'] & { _id: string };`);
            parameters = `input: ${inputTypeName}, options?: ${optionsTypeName}`;
            mergeParamsIntoVariables = `const { _id, ...rest } = input;
  const variables = { ...options, id: _id, input: rest }`;
          }
        }
        if (hasIdVariable && !hasInputVariable || isInvokeContract) {
          extraTypes.push(`export type ${optionsTypeName} = Omit<${o.operationVariablesTypes}, 'id'>;`);
          parameters = `id: string, options?: ${optionsTypeName}`;
          mergeParamsIntoVariables = `const variables = { ...options, id }`;
        }
      }
      let queryNameSuffix = "";
      let queryOperationName = operationName;
      if (operationName === "list") {
        queryNameSuffix = "Items";
      } else if (operationName.includes("Versions")) {
        queryNameSuffix = "Versions";
        queryOperationName = operationName.replace("Versions", "");
      }
      let queryName = `${queryOperationName}_${entityName}${queryNameSuffix}`;
      if (isVendiaOperation) {
        const vendiaType = vendiaNamespaceToTypeMap[entityName];
        queryName = `${queryOperationName}Vendia_${vendiaType}${queryNameSuffix}`;
      }
      let returnValueChain = `
      .then(res => res.${queryName})`;
      let resultType = `${o.operationResultType}['${queryName}']`;
      if (operationName === "list") {
        const verboseResponseField = queryName.slice(4);
        returnValueChain = `
      .then(res => { const updatedRes = { ...res.${queryName}, items: res.${queryName}?.${verboseResponseField}}; delete updatedRes.${verboseResponseField}; return updatedRes })`;
        resultType = `ReplaceVerboseFieldWithItems<${resultType}>`;
      }
      const operationsWithAliasedFieldResults = ["get", "list", "add", "create", "update"];
      if (isAclEnabled && operationsWithAliasedFieldResults.includes(operationName)) {
        let partialTypeName = `${this.config.schemaNamespace}_${entityName}_Partial_`;
        if (entityName === "contracts") {
          partialTypeName = "Vendia_Contract_Partial_";
        }
        if (operationName === "get") {
          returnValueChain += `
      .then(res => {
          return stripAliasPrefixesFromKeys<${partialTypeName}>(res);
      })`;
        } else if (operationName === "list") {
          returnValueChain += `
      .then(res => {
          const items = stripAliasPrefixesFromKeys<${partialTypeName}[]>(res.items);
          return { ...res, items };
      })`;
        } else {
          returnValueChain += `
      .then(res => {
          const result = stripAliasPrefixesFromKeys<${partialTypeName} | undefined>(res?.result);
          return { ...res, result };
      })`;
        }
      }
      const docVarName = this.getDocumentNodeVariable(o.documentVariableName);
      const returnLine = `return _requestWrapper((wrappedRequestHeaders) => { 
    return _gqlClient.request<${o.operationResultType}>(${docVarName}, variables, wrappedRequestHeaders)${returnValueChain}; 
  }, '${queryName}');`;
      if (o.operationType === "Subscription") {
        return `${operationName}(handler: (value: ${resultType}) => void): Unsubscribe {
  return _subscribe({query: ${docVarName}}, ({ data }: any) =>  { return handler(data.${queryName}) })
}`;
      }
      if (numVariables === 0) {
        parameters = "";
        mergeParamsIntoVariables = `const variables = {}`;
      }
      return `${operationName}(${parameters}) {
  ${mergeParamsIntoVariables}
  ${returnLine}
}`;
    }
  }
};
function capitalizeFirstLetter(string) {
  return string[0].toUpperCase() + string.slice(1);
}

// src/index.ts
var import_path = require("path");
var plugin = (schema, documents, config) => {
  const allAst = (0, import_graphql2.concatAST)(documents.map((v) => v.document));
  const allFragments = [
    ...allAst.definitions.filter((d) => d.kind === import_graphql2.Kind.FRAGMENT_DEFINITION).map(
      (fragmentDef) => ({
        node: fragmentDef,
        name: fragmentDef.name.value,
        onType: fragmentDef.typeCondition.name.value,
        isExternal: false
      })
    ),
    ...config.externalFragments || []
  ];
  const visitor = new GraphQLRequestVisitor(schema, allFragments, config);
  const visitorResult = (0, import_plugin_helpers.oldVisit)(allAst, { leave: visitor });
  return {
    prepend: visitor.getImports(),
    content: [
      visitor.fragments,
      ...visitorResult.definitions.filter((t) => typeof t === "string"),
      visitor.sdkContent
    ].join("\n")
  };
};
var validate = (schema, documents, config, outputFile) => __async(void 0, null, function* () {
  if ((0, import_path.extname)(outputFile) !== ".ts") {
    throw new Error(`Plugin "typescript-graphql-request" requires extension to be ".ts"!`);
  }
});
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  GraphQLRequestVisitor,
  plugin,
  validate
});
//# sourceMappingURL=index.js.map