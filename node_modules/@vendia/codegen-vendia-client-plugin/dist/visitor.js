import { ClientSideBaseVisitor, DocumentMode, getConfigValue, indentMultiline, } from '@graphql-codegen/visitor-plugin-common';
import autoBind from 'auto-bind';
import camelCase from 'camelcase';
import { print } from 'graphql';
// Underscores aren't allowed in entity names so we're safe to use
//  this simple separator in our generated query names.
// Pattern is <entity>__<operation>, eg query Product__get { ... }
const queryNameSeparator = '__';
const vendiaNamespaceToTypeMap = {
    blocks: 'Block',
    files: 'File',
    folders: 'Folder',
    contracts: 'Contract',
    settings: 'Settings',
    deployments: 'DeploymentInfo',
    uniInfo: 'UniInfo',
};
const additionalExportedTypes = `
export type SdkFunctionWrapper = <T>(action: (requestHeaders?:Record<string, string>) => Promise<T>, operationName: string) => Promise<T>;
`;
const additionalTypeHelpers = `
// Return value of subscriptions
export type Unsubscribe = () => void;
`;
export class GraphQLRequestVisitor extends ClientSideBaseVisitor {
    constructor(schema, fragments, rawConfig) {
        super(schema, fragments, rawConfig, {
            rawRequest: getConfigValue(rawConfig.rawRequest, false),
            extensionsType: getConfigValue(rawConfig.extensionsType, 'any'),
            schemaNamespace: getConfigValue(rawConfig.schemaNamespace, 'Self'),
            schemaJson: getConfigValue(rawConfig.schemaJson, {}),
        });
        this._operationsToInclude = [];
        autoBind(this);
        const typeImport = this.config.useTypeImports ? 'import type' : 'import';
        this._additionalImports.push(`${typeImport} { GraphQLClient } from 'graphql-request';`);
        this._additionalImports.push(`${typeImport} * as Dom from 'graphql-request/dist/types.dom';`);
        // if (this.config.rawRequest) {
        //   this._additionalImports.push(`${typeImport} { GraphQLError } from 'graphql-request/dist/types';`);
        //   if (this.config.documentMode !== DocumentMode.string) {
        //     this._additionalImports.push(`import { print } from 'graphql'`);
        //   }
        // }
    }
    OperationDefinition(node) {
        var _a;
        const operationName = (_a = node.name) === null || _a === void 0 ? void 0 : _a.value;
        if (!operationName) {
            // eslint-disable-next-line no-console
            console.warn(`Anonymous GraphQL operation was ignored in "typescript-graphql-request", please make sure to name your operation: `, print(node));
            return null;
        }
        return super.OperationDefinition(node);
    }
    // You can build up operations with this method and return a string, but each operation will be processed independently
    // Here we push all the operations together so we can build an SDK object in sdkContent method below
    buildOperation(node, documentVariableName, operationType, operationResultType, operationVariablesTypes) {
        this._operationsToInclude.push({
            node,
            documentVariableName,
            operationType,
            operationResultType,
            operationVariablesTypes,
        });
        return null;
    }
    getDocumentNodeVariable(documentVariableName) {
        return this.config.documentMode === DocumentMode.external
            ? `Operations.${documentVariableName}`
            : documentVariableName;
    }
    get sdkContent() {
        console.log('Generating TypeScript code...');
        const extraVariables = [];
        const extraTypes = [];
        const groupedOperationsByEntity = {};
        const groupedVendiaOperations = {};
        this._operationsToInclude.forEach((o) => {
            const operationGroup = o.node.name.value.split(queryNameSeparator)[0];
            if (operationGroup.startsWith('_')) {
                const vendiaGroup = operationGroup.slice(1);
                if (!groupedVendiaOperations[vendiaGroup]) {
                    groupedVendiaOperations[vendiaGroup] = [o];
                }
                else {
                    groupedVendiaOperations[vendiaGroup].push(o);
                }
            }
            else {
                if (!groupedOperationsByEntity[operationGroup]) {
                    groupedOperationsByEntity[operationGroup] = [o];
                }
                else {
                    groupedOperationsByEntity[operationGroup].push(o);
                }
            }
        });
        const groupedVendiaActions = {};
        Object.entries(groupedVendiaOperations).forEach(([vendiaNamespace, vendiaOperations]) => {
            const vendiaActions = vendiaOperations.map(buildAction.bind(this)).map((s) => indentMultiline(s, 2));
            groupedVendiaActions[vendiaNamespace] = vendiaActions.join(',\n');
        });
        const groupedActionsByEntity = Object.entries(groupedOperationsByEntity)
            .map(([entity, operations]) => {
            const actions = operations
                .map(buildAction.bind(this))
                .filter(Boolean)
                .map((s) => indentMultiline(s, 1));
            const camelCaseEntity = camelCase(entity, { preserveConsecutiveUppercase: true, locale: false });
            return `${camelCaseEntity}: {\n${actions.join(',\n')}\n}`;
        })
            .map((s) => indentMultiline(s, 2));
        return `
${additionalExportedTypes}
${additionalTypeHelpers}
${extraVariables.join('\n')}
${extraTypes.join('\n')}

const defaultWrapper: SdkFunctionWrapper = (action, _operationName) => action();

interface GetSdkNamespaceOptions {
  _gqlClient: GraphQLClient;
  _requestWrapper: SdkFunctionWrapper;
  _subscribe: any;
}


export function getEntities({_gqlClient, _subscribe, _requestWrapper = defaultWrapper}: GetSdkNamespaceOptions) {
  return {
${groupedActionsByEntity.join(',\n')}
  };
}

type GetEntities = ReturnType<typeof getEntities>

export function getBlocks({_gqlClient, _subscribe, _requestWrapper = defaultWrapper}: GetSdkNamespaceOptions) {
  return {
${groupedVendiaActions.blocks}
  };
}

type GetBlocks = ReturnType<typeof getBlocks>

export function getContracts({_gqlClient, _subscribe, _requestWrapper = defaultWrapper}: GetSdkNamespaceOptions) {
  return {
${groupedVendiaActions.contracts}
  };
}

type GetContracts = ReturnType<typeof getContracts>

export function getFiles({_gqlClient, _subscribe, _requestWrapper = defaultWrapper}: GetSdkNamespaceOptions) {
  return {
${groupedVendiaActions.files}
  };
}

type GetFiles = ReturnType<typeof getFiles>

export function getFolders({_gqlClient, _subscribe, _requestWrapper = defaultWrapper}: GetSdkNamespaceOptions) {
  return {
${groupedVendiaActions.folders}
  };
}

type GetFolders = ReturnType<typeof getFolders>

export function getDeployments({_gqlClient, _subscribe, _requestWrapper = defaultWrapper}: GetSdkNamespaceOptions) {
  return {
${groupedVendiaActions.deployments}
  };
}

type GetDeployments = ReturnType<typeof getDeployments>

export function getSettings({_gqlClient, _subscribe, _requestWrapper = defaultWrapper}: GetSdkNamespaceOptions) {
  return {
${groupedVendiaActions.settings}
  };
}

type GetSettings = ReturnType<typeof getSettings>

export function getUniInfo({_gqlClient, _subscribe, _requestWrapper = defaultWrapper}: GetSdkNamespaceOptions) {
  return {
${groupedVendiaActions.uniInfo}
  };
}

type GetUniInfo = ReturnType<typeof getUniInfo>


// For fields returned in the __Partial__ section of ACL queries, we alias each field with "__alias__" to avoid
// graphQL errors. Replace alias fields with their original field name (top-level fields only, not recursive)
const ALIAS_PREFIX = '__alias__';
// Use generics to retain the type that was passed in
function stripAliasPrefixesFromKeys<T>(value: any): T {
  // Handle top-level scalars
  if (typeof value === 'boolean' || typeof value === 'number' || typeof value === 'string' || value == null) {
    return value;
  }
  
  // Handles top-level arrays and top-level objects
  if (Array.isArray(value)) {
    return value.map((item) => stripAliasPrefixesFromKeys(item)) as unknown as T
  }

  const clean: any = {}
  Object.entries(value).forEach(([key, val]) => {
    if (key.startsWith(ALIAS_PREFIX)) {
      clean[key.replace(ALIAS_PREFIX, '')] = val
    } else {
      clean[key] = val
    }
  })
  return clean
}
`;
        // TODO - build all the response types and export them in the following format
        // type GetEntities = ReturnType<typeof getEntities>
        // export type ScalarGetResponse = GetEntities['scalar']['get']
        // export type ScalarCreateResponse = GetEntities['scalar']['create']
        function buildAction(o) {
            // console.log('-----------------------------------');
            // console.log('-----------------------------------');
            // console.log(o.node);
            // console.log('variable 1', o.node.variableDefinitions[0]?.variable.name.value);
            // console.log('variable 1', o.node.variableDefinitions[0]?.variable);
            // console.log('variable 2', o.node.variableDefinitions[1]?.variable.name.value);
            // console.log('variable 3', o.node.variableDefinitions[2]?.variable.name.value);
            var _a, _b, _c, _d, _e;
            // @ts-ignore - parses query name (eg, listVendia_FolderItems or list_ProductItems) to determine which are in-house Vendia APIs
            // const isVendiaOperation = o.node.selectionSet.selections[0].name.value.split('_')[0].includes('Vendia')
            // console.log(o.node.selectionSet.selections[0].name.value, isVendiaOperation);
            // entityName will be 'product' for user entity, 'files' or 'blocks' for Vendia APIs
            let entityName = o.node.name.value.split(queryNameSeparator)[0];
            // _contracts, _blocks, etc
            const isVendiaOperation = entityName.startsWith('_');
            if (isVendiaOperation) {
                // _contracts becomes contract, _uniInfo becomes uniInfo
                entityName = entityName.slice(1);
            }
            const numVariables = o.node.variableDefinitions.length;
            let operationName = o.node.name.value;
            // Rename method to just "list" or "add", etc.
            if (o.node.name.value.includes(queryNameSeparator)) {
                operationName = o.node.name.value.split(queryNameSeparator)[1];
            }
            // Need to handle some special cases for this one-off API
            const isInvokeContract = operationName === 'invoke' && entityName === 'contracts';
            const entitiesWithAcl = Object.values((_b = (_a = this.config.schemaJson) === null || _a === void 0 ? void 0 : _a['x-vendia-acls']) !== null && _b !== void 0 ? _b : {}).reduce((acc, { type }) => {
                acc[type] = true;
                return acc;
            }, {});
            // Special case for contracts, the only Vendia entity that has ACLs enabled
            const isAclEnabled = entitiesWithAcl[entityName] || isInvokeContract;
            // graphql-request uses "variables" nomenclature, but we're elevating required/primary input to first arg and the rest become "options"
            let parameters = `options?: ${o.operationVariablesTypes}`;
            // We have to build up variables from options, input, and possibly id parameters. In case we don't just use this.
            let mergeParamsIntoVariables = `const variables = options`;
            // Have to build a new type for options minus whatever we're promoting to the first/second parameters for some operations
            const optionsTypeName = `${entityName}${capitalizeFirstLetter(operationName)}OptionsParameter`;
            const hasInputVariable = o.node.variableDefinitions.find((v) => { var _a, _b; return ((_b = (_a = v === null || v === void 0 ? void 0 : v.variable) === null || _a === void 0 ? void 0 : _a.name) === null || _b === void 0 ? void 0 : _b.value) === 'input'; });
            const hasIdVariable = o.node.variableDefinitions.find((v) => { var _a, _b; return ((_b = (_a = v === null || v === void 0 ? void 0 : v.variable) === null || _a === void 0 ? void 0 : _a.name) === null || _b === void 0 ? void 0 : _b.value) === 'id'; });
            if (o.operationType === 'Query') {
                // product.get(id, options) instead of product.get(options)
                if (operationName === 'get' && hasIdVariable) {
                    extraTypes.push(`export type ${optionsTypeName} = Omit<${o.operationVariablesTypes}, 'id'>;`);
                    parameters = `id: string, options?: ${optionsTypeName}`;
                    mergeParamsIntoVariables = `const variables = { ...options, id }`;
                }
            }
            if (o.operationType === 'Mutation') {
                // Must be an add/create mutation
                if (hasInputVariable && !hasIdVariable) {
                    if (numVariables === 1) {
                        // Don't include options param when there are ZERO additional options besides input
                        parameters = `input: ${o.operationVariablesTypes}['input']`;
                        mergeParamsIntoVariables = `const variables = { input }`;
                    }
                    else {
                        // Build a new type for the rest of the options minus 'input'
                        extraTypes.push(`export type ${optionsTypeName} = Omit<${o.operationVariablesTypes}, 'input'>;`);
                        // There are additional options besides input, accept them and merge them into the variables
                        parameters = `input: ${o.operationVariablesTypes}['input'], options?: ${optionsTypeName}`;
                        mergeParamsIntoVariables = `const variables = { ...options, input }`;
                    }
                }
                // Must be a put/update mutation
                if (hasInputVariable && hasIdVariable && !isInvokeContract) {
                    // Is input a scalar or object? If it's an object, we can pull _id out of it and pass that to id variable
                    // @ts-ignore - maybe this is a bug, but this is where the type is located in the AST and typescript doesn't think it should exist...
                    const isStringInput = ((_e = (_d = (_c = hasInputVariable === null || hasInputVariable === void 0 ? void 0 : hasInputVariable.type) === null || _c === void 0 ? void 0 : _c.type) === null || _d === void 0 ? void 0 : _d.name) === null || _e === void 0 ? void 0 : _e.value) === 'String';
                    // Build a new type for the rest of the options minus 'id' and 'input'
                    extraTypes.push(`export type ${optionsTypeName} = Omit<${o.operationVariablesTypes}, 'id' | 'input'>;`);
                    if (isStringInput) {
                        // product.update(id: string, input: string, condition: )
                        parameters = `id: string, input: string, options?: ${optionsTypeName}`;
                        mergeParamsIntoVariables = `const variables = { ...options, id, input }`;
                    }
                    else {
                        // Nicer API to mutate objects - just pass in the same object you'd receive from a get() and we split the id out for you
                        // product.update(input: { _id: string, name: string })
                        // Build a new type which includes _id
                        const inputTypeName = `${entityName}${capitalizeFirstLetter(operationName)}InputParameter`;
                        extraTypes.push(`export type ${inputTypeName} = ${o.operationVariablesTypes}['input'] & { _id: string };`);
                        // Extract _id from the new input type and pass it to the id variable
                        parameters = `input: ${inputTypeName}, options?: ${optionsTypeName}`;
                        mergeParamsIntoVariables = `const { _id, ...rest } = input;\n  const variables = { ...options, id: _id, input: rest }`;
                    }
                }
                // Must be a delete mutation (or invoke contract!)
                if ((hasIdVariable && !hasInputVariable) || isInvokeContract) {
                    // product.delete(id: string)
                    // Build a new type for the rest of the options minus 'id'
                    extraTypes.push(`export type ${optionsTypeName} = Omit<${o.operationVariablesTypes}, 'id'>;`);
                    parameters = `id: string, options?: ${optionsTypeName}`;
                    mergeParamsIntoVariables = `const variables = { ...options, id }`;
                }
            }
            // Note: improve response ergonomics!
            // We don't support batch queries, so we can simplify query responses - don't
            // include the outer query wrapper (eg, list__ProductItems)
            let queryNameSuffix = '';
            let queryOperationName = operationName;
            if (operationName === 'list') {
                queryNameSuffix = 'Items';
            }
            else if (operationName.includes('Versions')) {
                queryNameSuffix = 'Versions';
                queryOperationName = operationName.replace('Versions', '');
            }
            let queryName = `${queryOperationName}_${entityName}${queryNameSuffix}`;
            if (isVendiaOperation) {
                // 'blocks' becomes 'Block'
                const vendiaType = vendiaNamespaceToTypeMap[entityName];
                queryName = `${queryOperationName}Vendia_${vendiaType}${queryNameSuffix}`;
            }
            // Extract the value located at the query name in response
            let returnValueChain = `\n      .then(res => res.${queryName})`;
            let resultType = `${o.operationResultType}['${queryName}']`;
            // Doing some extra work for list operations - replacing the _EntityItems field
            // with a consistent "items" field to make responses easier and more predictable
            if (operationName === 'list') {
                // Cut "list" off of "list_ProductItems" or "listVendia_FileItems"
                const verboseResponseField = queryName.slice(4);
                returnValueChain = `\n      .then(res => { const updatedRes = { ...res.${queryName}, items: res.${queryName}?.${verboseResponseField}}; delete updatedRes.${verboseResponseField}; return updatedRes })`;
                resultType = `ReplaceVerboseFieldWithItems<${resultType}>`;
            }
            // ----- Help users with ACLs -----
            // Doing some extra work for get/list operations that might have ACLs enabled - strip the aliases off for the user!
            // More context: for fields returned in the __Partial__ section of ACL queries, we alias each field with "__alias__" to avoid
            // graphQL errors. Replace alias fields with their original field name (top-level fields only, not recursive)
            const operationsWithAliasedFieldResults = ['get', 'list', 'add', 'create', 'update'];
            if (isAclEnabled && operationsWithAliasedFieldResults.includes(operationName)) {
                let partialTypeName = `${this.config.schemaNamespace}_${entityName}_Partial_`;
                if (entityName === 'contracts') {
                    partialTypeName = 'Vendia_Contract_Partial_';
                }
                // Note the += operator, we're chaining another .then()
                if (operationName === 'get') {
                    returnValueChain += `\n      .then(res => {
          return stripAliasPrefixesFromKeys<${partialTypeName}>(res);
      })`;
                }
                else if (operationName === 'list') {
                    returnValueChain += `\n      .then(res => {
          const items = stripAliasPrefixesFromKeys<${partialTypeName}[]>(res.items);
          return { ...res, items };
      })`;
                }
                else {
                    // The mutations all follow same pattern with aliased fields in result
                    // Note: ${partialTypeName} | undefined is quick way to tell typescript that result won't be there for ASYNC mutations
                    returnValueChain += `\n      .then(res => {
          const result = stripAliasPrefixesFromKeys<${partialTypeName} | undefined>(res?.result);
          return { ...res, result };
      })`;
                }
            }
            // Return line for queries and mutations
            const docVarName = this.getDocumentNodeVariable(o.documentVariableName);
            const returnLine = `return _requestWrapper((wrappedRequestHeaders) => { 
    return _gqlClient.request<${o.operationResultType}>(${docVarName}, variables, wrappedRequestHeaders)${returnValueChain}; 
  }, '${queryName}');`;
            // ----- Subscriptions! -----
            // TODO - add support for stripping ACL aliases when we fix subscriptions ACL bug
            if (o.operationType === 'Subscription') {
                return `${operationName}(handler: (value: ${resultType}) => void): Unsubscribe {
  return _subscribe({query: ${docVarName}}, ({ data }: any) =>  { return handler(data.${queryName}) })
}`;
            }
            // May never need rawRequest so focusing on basic request for now, can refactor to add this back later if needed
            //       if (this.config.rawRequest) {
            //         let docArg = docVarName;
            //         if (this.config.documentMode !== DocumentMode.string) {
            //           docArg = `${docVarName}String`;
            //           extraVariables.push(`const ${docArg} = print(${docVarName});`);
            //         }
            //         return `${operationName}(variables${variablesAreOptional ? '?' : ''}: ${
            //           o.operationVariablesTypes
            //         }, requestHeaders?: Dom.RequestInit["headers"]): Promise<{ data?: ${
            //           o.operationResultType
            //         } | undefined; extensions?: ${
            //           this.config.extensionsType
            //         }; headers: Dom.Headers; status: number; errors?: GraphQLError[] | undefined; }> {
            //     return _requestWrapper((wrappedRequestHeaders) => _gqlClient.rawRequest<${
            //           o.operationResultType
            //         }>(${docArg}, variables, {...requestHeaders, ...wrappedRequestHeaders}), '${operationName}');
            // }`;
            //       } else {
            // If there are zero variables, don't ask users for an options object
            // Top-level scalar get(), uniInfo.get()
            if (numVariables === 0) {
                parameters = '';
                mergeParamsIntoVariables = `const variables = {}`;
            }
            // TODO - seems like I can clean up a lot of my code trying to come up with accurate types for the return value of the operation
            //  Typescript is smart enough to figure it out by inferring from the code I'm adding - if this works, remove all resultType stuff above
            //  return `${operationName}(${parameters}): Promise<${resultType}> {
            return `${operationName}(${parameters}) {
  ${mergeParamsIntoVariables}
  ${returnLine}
}`;
        }
    }
}
function capitalizeFirstLetter(string) {
    return string[0].toUpperCase() + string.slice(1);
}
